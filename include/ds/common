#pragma once
#ifndef DS_COMMON
#define DS_COMMON

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cstdio>
#include <cassert>
#include <exception>
#include <new>
#include "macros"

#ifdef min
#	undef min
#endif
#ifdef max
#	undef max
#endif

namespace ds {

using std::exception;
using std::bad_alloc;
using std::nothrow_t;
using std::nothrow;
using std::nullptr_t;
using byte_t       = unsigned char;
using align_t      = size_t;
using byte_ptr_t   = byte_t *;
using byte_cptr_t  = byte_t const *;
using max_align_t  = std::max_align_t;
using noinit_t     = struct {};

template <size_t size_, typename T>
using fixed_ref_t  = T (&)[size_];
template <size_t size_, typename T>
using fixed_cref_t = T const (&)[size_];
template <size_t size_, typename T>
using fixed_ptr_t  = T (*)[size_];
template <size_t size_, typename T>
using fixed_cptr_t = T const (*)[size_];

template <typename E>
using array_ref_t = E (&)[];
template <typename E>
using array_cref_t = E const (&)[];
template <typename E>
using array_ptr_t = E (*)[];
template <typename E>
using array_cptr_t = E const (*)[];

template <typename T>
struct in_place_t {};

static constexpr noinit_t noinit = noinit_t {};
static constexpr double   nanf   = float(__builtin_nan("0"));
static constexpr double   nan    = double(__builtin_nan("0"));
#if defined(__GNUC__)
static constexpr double   inff   = float(__builtin_inf());
static constexpr double   inf    = double(__builtin_inf());
#else
static constexpr double   inff   = float(1e300 * 1e300);
static constexpr double   inf    = double(1e300 * 1e300);
#endif

template <typename T> static constexpr T decl();

template <typename T> struct remove_cv                   { using type = T; };
template <typename T> struct remove_cv<T const>          { using type = T; };
template <typename T> struct remove_cv<T volatile>       { using type = T; };
template <typename T> struct remove_cv<T const volatile> { using type = T; };
template <typename T>
using remove_cv_t = typename remove_cv<T>::type;

template <typename T> struct remove_reference       { using type = T; };
template <typename T> struct remove_reference<T &>  { using type = T; };
template <typename T> struct remove_reference<T &&> { using type = T; };
template <typename T>
using remove_reference_t = typename remove_reference<T>::type;

template <typename T>
using remove_cvref_t = remove_cv_t<remove_reference_t<T>>;

template <bool condition_, typename T>
struct enable_if {};
template <typename T>
struct enable_if<true,T> { using type = T; };
template <bool condition_, typename T>
using enable_if_t = typename enable_if<condition_,T>::type;

template <bool condition_, typename T, typename F>
struct conditional { using type = F; };
template <typename T, typename F>
struct conditional<true,T,F> { using type = T; };
template <bool condition_, typename T, typename F>
using conditional_t = typename conditional<condition_,T,F>::type;

template <typename T, T value_>
struct integral_constant
{
	static constexpr T value = value_;
	constexpr integral_constant() = default;
	constexpr T operator()() const noexcept { return value; };
	constexpr operator T() const noexcept { return value; };
};

template <bool value_>
using bool_constant = integral_constant<bool,value_>;

using false_type = bool_constant<false>;
using true_type  = bool_constant<true>;

template <typename... Ts>
struct are_all_true : false_type {};

namespace _ {

	template <typename T, bool = T::value, typename... Ts>
	struct _are_all_true : false_type {};
	template <typename T, typename... Ts>
	struct _are_all_true<T,true,Ts...> : bool_constant<are_all_true<Ts...>::value> {};
	template <typename T, typename... Ts>
	struct _are_all_true<T,false,Ts...> : false_type {};

} // namespace _

template <typename T, typename... Ts>
struct are_all_true<T,Ts...> : bool_constant<_::_are_all_true<T,T::value,Ts...>::value> {};

template <typename... Ts>
struct are_all_false : false_type {};

namespace _ {

	template <typename T, bool = T::value, typename... Ts>
	struct _are_all_false : false_type {};
	template <typename T, typename... Ts>
	struct _are_all_false<T,false,Ts...> : bool_constant<are_all_false<Ts...>::value> {};
	template <typename T, typename... Ts>
	struct _are_all_false<T,true,Ts...> : false_type {};

} // namespace _

template <typename T, typename... Ts>
struct are_all_false<T,Ts...> : bool_constant<_::_are_all_false<T,T::value,Ts...>::value> {};

template <typename T> 
struct is_const : false_type {};
template <typename T> 
struct is_const<T const> : true_type {};

template <typename T> 
struct is_reference : false_type {};
template <typename T> 
struct is_reference<T &> : true_type {};
template <typename T> 
struct is_reference<T &&> : true_type {};

template <typename T, typename U> 
struct is_same : false_type {};
template <typename T> 
struct is_same<T,T> : true_type {};

template <typename T, typename... Ts>
struct is_type_in_pack : false_type {};
template <typename T>
struct is_type_in_pack<T> : false_type {};
template <typename T, typename U, typename... Ts>
struct is_type_in_pack<T,U,Ts...> { static constexpr bool value = is_type_in_pack<T,Ts...>::value; };
template <typename T, typename... Ts>
struct is_type_in_pack<T,T,Ts...> : true_type {};

template <typename T>
struct is_integral 
{
	static constexpr bool value = is_type_in_pack<remove_cv_t<T>
			, bool
			, char, char16_t, char32_t, wchar_t
			, signed char, unsigned char
			, signed short, unsigned short
			, signed int, unsigned int
			, signed long, unsigned long
			, signed long long, unsigned long long
		>::value;
};

template <typename T>
struct is_floating_point 
{
	static constexpr bool value = is_type_in_pack<remove_cv_t<T>
			, float
			, double
			, long double
		>::value;
};

template <typename T> 
struct is_arithmetic { static constexpr bool value = is_integral<T>::value || is_floating_point<T>::value; }; 

template <typename T> 
struct is_enum { static constexpr bool value = __is_enum(T); };

template <typename T> 
struct is_union { static constexpr bool value = __is_union(T); };

namespace _ {
	template <typename T> bool_constant<!is_union<T>::value> class_test(int T::*);
	template <typename T> false_type class_test(...);
} // namespace _

template <typename T>
struct is_class : decltype(_::class_test<T>(nullptr)) {};

template <typename T> 
struct is_function 
{
	static constexpr bool value = 
		!is_class<T>::value && !is_const<T const>::value && !is_reference<T>::value;
};

namespace _ {
	template <typename T> 
	struct is_pointer : false_type {};
	template <typename T> 
	struct is_pointer<T *> : true_type {};
} // namespace _

template <typename T> 
struct is_pointer : bool_constant<_::is_pointer<remove_cv_t<T>>::value> {};

template <typename T> 
struct is_member_pointer : false_type {};
template <typename T, class C> 
struct is_member_pointer<T C::*> : true_type {};

template <typename T> 
struct is_member_object_pointer : false_type {};
template <typename T, class C> 
struct is_member_object_pointer<T C::*> : bool_constant<!is_function<T>::value> {};

template <typename T> 
struct is_member_function_pointer : false_type {};
template <typename T, class C> 
struct is_member_function_pointer<T C::*> : bool_constant<is_function<T>::value> {};

template <typename T>
struct is_scalar : bool_constant<
		   is_arithmetic<T>::value 
		|| is_enum<T>::value 
		|| is_pointer<T>::value 
		|| is_same<remove_cv_t<T>,nullptr_t>::value
	> 
{};

namespace _ {
	template <typename T, typename = decltype(decl<T &>().~T())>
	true_type test_destructible(int); 
	template <typename T>
	false_type test_destructible(...); 
} // namespace _

template <typename T> 
struct is_destructible : decltype(_::test_destructible<T>(0)) {};

#if defined(_MSC_VER) || defined(__clang__)
template <typename T> 
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(T)> {};
#else
template <typename T> 
struct is_trivially_destructible : bool_constant<is_destructible<T>::value && __has_trivial_destructor(T)> 
{};
#endif

template <typename T, typename... Args> 
struct is_constructible : bool_constant<__is_constructible(T,Args...)> {};

template <typename T, typename... Args> 
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(T,Args...)> {};

template <typename T> 
using is_copy_constructible = is_constructible<T,remove_cvref_t<T> const &>;

template <typename T> 
using is_trivially_copy_constructible = is_trivially_constructible<T,remove_cvref_t<T> const &>;

template <typename T> 
using is_move_constructible = is_constructible<T,remove_cvref_t<T> &&>;

template <typename T> 
using is_trivially_move_constructible = is_trivially_constructible<T,remove_cvref_t<T> &&>;

template <typename T, typename U> 
struct is_assignable : bool_constant<__is_assignable(T,U)> {};

template <typename T, typename U> 
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(T,U)> {};

template <typename T> 
using is_copy_assignable = is_assignable<T,remove_cvref_t<T> const &>;

template <typename T> 
using is_move_assignable = is_assignable<T,remove_cvref_t<T> &&>;

template <typename T> 
using is_trivially_copy_assignable = is_trivially_assignable<T,remove_cvref_t<T> const &>;

template <typename T> 
using is_trivially_move_assignable = is_trivially_assignable<T,remove_cvref_t<T> &&>;

template <typename To, typename From, typename... Ts>
struct is_constructible_by_all : bool_constant<
		   is_constructible<To,From>::value 
		&& is_constructible_by_all<To,Ts...>::value
	>
{};

template <typename To, typename From>
struct is_constructible_by_all<To,From> : bool_constant<is_constructible<To,From>::value> {};

namespace _ {

	template <typename T, typename = decltype(decl<T &>().swap(decl<T &>()))>
	true_type _has_swap(int);
	template <typename T>
	false_type _has_swap(...);

} // namespace _

template <typename T>
struct has_swap : decltype(_::_has_swap<T>(0)) {};

namespace _ {

	template <class OST, typename T, typename = decltype(decl<OST &>() >> decl<T const &>())>
	true_type is_in_streamable(int);
	template <class OST, typename T>
	false_type is_in_streamable(...);

	template <class OST, typename T, typename = decltype(decl<OST &>() << decl<T const &>())>
	true_type is_out_streamable(int);
	template <class OST, typename T>
	false_type is_out_streamable(...);

} // namespace _


template <typename T>
struct is_string : false_type {};

template <>
struct is_string<char *> : true_type {};

template <>
struct is_string<char[]> : true_type {};

template <size_t size_>
struct is_string<char[size_]> : true_type {};


template <class OST, typename T>
struct is_in_streamable : decltype(_::is_in_streamable<OST,T>(0)) {};

template <class OST, typename T>
struct is_out_streamable : decltype(_::is_out_streamable<OST,T>(0)) {};

template <typename T, typename U>
static constexpr T min(T const & lhs, U rhs) noexcept { return lhs < rhs ? lhs : rhs; }

template <typename T, typename U>
static constexpr T max(T const & lhs, U rhs) noexcept { return lhs > rhs ? lhs : rhs; }

template <typename T>
static constexpr T abs(T const & rhs) { return rhs < 0 ? -rhs : rhs; }

template <typename T>
static constexpr bool 
is_prime(T value) noexcept
{
	T N = value;
	for(T i = 2; i <= N; ++i, N /= i)
		if(value % i == 0)
			return false;
	return true;
}

template <typename T>
static constexpr T 
next_prime(T value) noexcept
{
	while(!is_prime(++value));
	return value;
}

template <typename T, size_t size_>
static fixed_cref_t<size_,T>
gen_prime_squares() noexcept
{
	static size_t prime_squares[size_];
	size_t prime_ = 1;
	for(auto & e : prime_squares)
	{
		prime_ = next_prime<size_t>(prime_);
		e = prime_ * prime_;
	}
	return prime_squares;
}

template <typename T, size_t size_>
static fixed_cref_t<size_,T>
init_prime_squares() noexcept
{
	static auto & prime_squares = gen_prime_squares<T,size_>();
	return prime_squares;
}

template <typename T>
struct usage { static constexpr size_t value = 0; };

template <typename T, size_t count_>
struct usage_n { static constexpr size_t value = 0; };

template <typename T, size_t size_>
struct usage_s { static constexpr size_t value = 0; };

template <typename T, size_t size_, size_t count_>
struct usage_sn { static constexpr size_t value = 0; };

template <typename T, bool is_signed = bool(T(-1) < T(0)), size_t = sizeof(T)>
struct max_integral
{};
template <typename T>
struct max_integral<T,true,1> : integral_constant<T,T(0x7F)>
{};
template <typename T>
struct max_integral<T,true,2> : integral_constant<T,T(0x7FFF)>
{};
template <typename T>
struct max_integral<T,true,4> : integral_constant<T,T(0x7FFFFFFF)>
{};
template <typename T>
struct max_integral<T,true,8> : integral_constant<T,T(0x7FFFFFFFFFFFFFFF)>
{};
template <typename T>
struct max_integral<T,false,1> : integral_constant<T,T(0xFF)>
{};
template <typename T>
struct max_integral<T,false,2> : integral_constant<T,T(0xFFFF)>
{};
template <typename T>
struct max_integral<T,false,4> : integral_constant<T,T(0xFFFFFFFF)>
{};
template <typename T>
struct max_integral<T,false,8> : integral_constant<T,T(0xFFFFFFFFFFFFFFFF)>
{};

template <typename T, bool is_signed = bool(T(-1) < T(0)), size_t = sizeof(T)>
struct min_integral
{};
template <typename T>
struct min_integral<T,true,1> : integral_constant<T,T(0x80)>
{};
template <typename T>
struct min_integral<T,true,2> : integral_constant<T,T(0x8000)>
{};
template <typename T>
struct min_integral<T,true,4> : integral_constant<T,T(0x80000000)>
{};
template <typename T>
struct min_integral<T,true,8> : integral_constant<T,T(0x8000000000000000)>
{};
template <typename T>
struct min_integral<T,false,1> : integral_constant<T,T(0x0)>
{};
template <typename T>
struct min_integral<T,false,2> : integral_constant<T,T(0x0)>
{};
template <typename T>
struct min_integral<T,false,4> : integral_constant<T,T(0x0)>
{};
template <typename T>
struct min_integral<T,false,8> : integral_constant<T,T(0x0)>
{};

template <typename T>
struct max_floating
{};
template <>
struct max_floating<float>
{
	static constexpr float value { 3.402823466e+38F };
};
template <>
struct max_floating<double>
{
	static constexpr double value { 1.7976931348623158e+308 };
};
template <>
struct max_floating<long double>
{
	static constexpr long double value { 1.7976931348623158e+308L };
};
constexpr float       max_floating<float>::value;
constexpr double      max_floating<double>::value;
constexpr long double max_floating<long double>::value;

template <typename T>
struct min_floating
{};
template <>
struct min_floating<float>
{
	static constexpr float value { -3.402823466e+38F };
};
template <>
struct min_floating<double>
{
	static constexpr double value { -1.7976931348623158e+308 };
};
template <>
struct min_floating<long double>
{
	static constexpr long double value { -1.7976931348623158e+308L };
};
constexpr float       min_floating<float>::value;
constexpr double      min_floating<double>::value;
constexpr long double min_floating<long double>::value;

template <typename T, int = (is_integral<T>::value ? 1 : (is_floating_point<T>::value ? 2 : 0))>
struct max_limit
{};
template <typename T>
struct max_limit<T,1> : max_integral<T>
{};
template <typename T>
struct max_limit<T,2> : max_floating<T>
{};

template <typename T, int = (is_integral<T>::value ? 1 : (is_floating_point<T>::value ? 2 : 0))>
struct min_limit
{};
template <typename T>
struct min_limit<T,1> : min_integral<T>
{};
template <typename T>
struct min_limit<T,2> : min_floating<T>
{};


template <typename T>
struct integral_index {};
template <> struct integral_index<int8_t>   : integral_constant<size_t,0> {};
template <> struct integral_index<uint8_t>  : integral_constant<size_t,1> {};
template <> struct integral_index<int16_t>  : integral_constant<size_t,2> {};
template <> struct integral_index<uint16_t> : integral_constant<size_t,3> {};
template <> struct integral_index<int32_t>  : integral_constant<size_t,4> {};
template <> struct integral_index<uint32_t> : integral_constant<size_t,5> {};
template <> struct integral_index<int64_t>  : integral_constant<size_t,6> {};
template <> struct integral_index<uint64_t> : integral_constant<size_t,7> {};

template <typename T>
struct floating_point_index {};
template <> struct floating_point_index<float>       : integral_constant<size_t,0> {};
template <> struct floating_point_index<double>      : integral_constant<size_t,1> {};
template <> struct floating_point_index<long double> : integral_constant<size_t,2> {};

static constexpr char const * integral_format[]
{
	"%hhd", "%hhu", "%hd", "%hu", "%ld", "%lu", "%lld", "%llu"
};

static constexpr char const * floating_point_format[]
{
	"%f", "%lf", "%Lf"
};

static constexpr char const * floating_point_scientific_format[]
{
	"%e", "%le", "%Le"
};

static constexpr char const * floating_point_generic_format[]
{
	"%g", "%lg", "%Lg"
};

template<typename T> struct Hasher {};
template<> struct Hasher<bool>       { static constexpr size_t hash(bool value)     noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char>       { static constexpr size_t hash(char value)     noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char16_t>   { static constexpr size_t hash(char16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char32_t>   { static constexpr size_t hash(char32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<wchar_t>    { static constexpr size_t hash(wchar_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int8_t>     { static constexpr size_t hash(int8_t value)   noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint8_t>    { static constexpr size_t hash(uint8_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int16_t>    { static constexpr size_t hash(int16_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint16_t>   { static constexpr size_t hash(uint16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int32_t>    { static constexpr size_t hash(int32_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint32_t>   { static constexpr size_t hash(uint32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int64_t>    { static constexpr size_t hash(int64_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint64_t>   { static constexpr size_t hash(uint64_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<nullptr_t>  { static constexpr size_t hash(nullptr_t)      noexcept { return 0; } };
template<class T> struct Hasher<T *> { static inline    size_t hash(T const * ptr)  noexcept { return size_t(ptr); } };

template<size_t size_> 
struct Hasher<char[size_]>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		static constexpr size_t prime_sq_size = 512;
		auto const & prime_squares = init_prime_squares<size_t,prime_sq_size>();
		if(!pstring)
			return 0;
		size_t hash_ = 0;
		for(size_t i = 0; i < size_ && pstring[i] != '\0'; ++i)
			hash_ += size_t(pstring[i]) * prime_squares[i % prime_sq_size];
		return hash_;
	}

};

template <>
struct Hasher<char[]>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		static constexpr size_t prime_sq_size = 512;
		auto const & prime_squares = init_prime_squares<size_t,prime_sq_size>();
		if(!pstring)
			return 0;
		size_t hash_ = 0;
		for(size_t i = 0; pstring[i] != '\0'; ++i)
			hash_ += size_t(pstring[i]) * prime_squares[i % prime_sq_size];
		return hash_;
	}

};

template<typename T>
using hasher = Hasher<T>;

template<typename T> struct OrderedHasher {};
template<> struct OrderedHasher<bool>        : integral_constant<size_t,max_integral<size_t,false,sizeof(bool)>::value> { static constexpr size_t hash(bool value)     noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char>        : integral_constant<size_t,max_integral<size_t,false,sizeof(char)>::value> { static constexpr size_t hash(char value)     noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char16_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(char16_t)>::value> { static constexpr size_t hash(char16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char32_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(char32_t)>::value> { static constexpr size_t hash(char32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<wchar_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(wchar_t)>::value> { static constexpr size_t hash(wchar_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int8_t>      : integral_constant<size_t,max_integral<size_t,false,sizeof(int8_t)>::value> { static constexpr size_t hash(int8_t value)   noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint8_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(uint8_t)>::value> { static constexpr size_t hash(uint8_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int16_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int16_t)>::value> { static constexpr size_t hash(int16_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint16_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint16_t)>::value> { static constexpr size_t hash(uint16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int32_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int32_t)>::value> { static constexpr size_t hash(int32_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint32_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint32_t)>::value> { static constexpr size_t hash(uint32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int64_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int64_t)>::value> { static constexpr size_t hash(int64_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint64_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint64_t)>::value> { static constexpr size_t hash(uint64_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<nullptr_t>   : integral_constant<size_t,max_integral<size_t>::value> { static constexpr size_t hash(nullptr_t)      noexcept { return 0; } };
template<class T> struct OrderedHasher<T *>  : integral_constant<size_t,max_integral<size_t>::value> { static inline    size_t hash(T const * ptr)  noexcept { return size_t(ptr); } };

template<size_t size_> 
struct OrderedHasher<char[size_]> : integral_constant<size_t,max_integral<size_t>::value>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		if(!pstring)
			return 0;
		size_t ordered_hash_ = 0;
		size_t min_size = min(sizeof(size_t), size_);
		for(size_t i = 0; i < min_size && pstring[i] != '\0'; ++i)
			ordered_hash_ |= size_t(pstring[i]) << ((sizeof(size_t) - i - 1) * 8);
		return ordered_hash_;
	}

};

template <>
struct OrderedHasher<char[]> : integral_constant<size_t,max_integral<size_t>::value>
{
	static size_t 
	hash(char const * pstring) noexcept
	{
		if(!pstring)
			return 0;
		size_t ordered_hash_ = 0;
		for(size_t i = 0; i < sizeof(size_t) && pstring[i] != '\0'; ++i)
			ordered_hash_ |= size_t(pstring[i]) << ((sizeof(size_t) - i - 1) * 8);
		return ordered_hash_;
	}

};

template<typename T>
using ordered_hasher = OrderedHasher<T>;

namespace _ {

	template <typename T, typename E = T, typename = decltype(Hasher<E>::hash(decl<T>()))>
	static constexpr true_type
	is_hashable(int); 
	template <typename T, typename E = T>
	static constexpr false_type
	is_hashable(...); 

	template <typename T, typename E = T, typename = decltype(OrderedHasher<E>::hash(decl<T>()))>
	static constexpr true_type
	is_ordered_hashable(int); 
	template <typename T, typename E = T>
	static constexpr false_type
	is_ordered_hashable(...); 

} // namespace _

template <typename T, typename E = T>
struct is_hashable : decltype(_::is_hashable<T,E>(0)) {};

template <typename T, typename E = T>
struct is_ordered_hashable : decltype(_::is_ordered_hashable<T,E>(0)) {};


template <typename T, T... sequence_>
struct integer_sequence {};

namespace _ {

	template <typename T, T start_, T end_, bool = (start_ < end_), T i_ = start_, T... sequence_>
	struct integer_sequence_maker
	{};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,start_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,true,start_+1,sequence_...,start_>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,i_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,true,i_+1,sequence_...,i_>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,start_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,false,start_-1,sequence_...,start_>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,i_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,false,i_-1,sequence_...,i_>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, bool = (start_ < end_), T i_ = start_, T... sequence_>
	struct reverse_integer_sequence_maker
	{};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,start_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,true,start_+1,start_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,i_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,true,i_+1,i_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,start_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,false,start_-1,start_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,i_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,false,i_-1,i_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};

} // namespace _

template <typename T, T start_, T end_>
using make_integer_sequence_t = typename _::integer_sequence_maker<T,start_,end_>::type;

template <typename T, T start_, T end_>
using make_reverse_integer_sequence_t = typename _::reverse_integer_sequence_maker<T,start_,end_>::type;

template <size_t... indices_>
using index_sequence = integer_sequence<size_t,indices_...>;

template <size_t start_, size_t end_>
using make_index_sequence_t = typename _::integer_sequence_maker<size_t,start_,end_>::type;

template <size_t start_, size_t end_>
using make_reverse_index_sequence_t = typename _::reverse_integer_sequence_maker<size_t,start_,end_>::type;


template <size_t index_, typename... Ts>
struct type_at_index
{
	using type = void;
};

template <size_t index_, typename T, typename... Ts>
struct type_at_index<index_,T,Ts...>
{
	using type = typename type_at_index<index_-1,Ts...>::type;
};

template <typename T, typename... Ts>
struct type_at_index<0,T,Ts...>
{
	using type = T;
};

template <size_t index_, typename T, typename... Ts>
using type_at_index_t = typename type_at_index<index_,T,Ts...>::type;


template <typename T, size_t start_ = 0, typename... Ts>
struct type_index : integral_constant<size_t,size_t(-1)> {};

template <typename T, size_t start_, typename U, typename... Ts>
struct type_index<T,start_,U,Ts...> : integral_constant<size_t,type_index<T,start_+1,Ts...>::value> {};

template <typename T, size_t start_, typename... Ts>
struct type_index<T,start_,T,Ts...> : integral_constant<size_t,start_> {};


// equal to
template <typename L, typename R = L>
struct equal
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs == rhs; } };

// less than
template <typename L, typename R = L>
struct less
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs < rhs; } };

// greater than
template <typename L, typename R = L>
struct greater
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs > rhs; } };

// less than or equal to
template <typename T>
struct less_or_equal
{ constexpr bool operator() (T const & lhs, T const & rhs) const noexcept { return lhs <= rhs; } };

// greater than or equal to
template <typename L, typename R = L>
struct greater_or_equal
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs >= rhs; } };



/** 
 * forward cast a universal reference.
 * 
 * T __________ T &&
 * T const ____ T const &&
 * T & ________ T &
 * T const & __ T const &
 * T && _______ T &&
 * T const && _ T const &&
 * 
 */
template <typename T> 
DS_nodiscard static constexpr T && 
forward(remove_reference_t<T> & t) noexcept 
{ return static_cast<T &&>(t); }

// cast to T && -- non-const move
// ds::move does not support moving const types unlike std::move
template <typename T, enable_if_t<(!is_const<remove_reference_t<T>>::value),int> = 0>
DS_nodiscard static constexpr remove_reference_t<T> &&
move(T && rhs) noexcept
{
	return static_cast<remove_reference_t<T> &&>(rhs);
}

// cast to T const && -- const move
template <typename T, enable_if_t<(is_const<remove_reference_t<T>>::value),int> = 0>
DS_nodiscard static constexpr remove_reference_t<T> const &&
cmove(T && rhs) noexcept
{
	return static_cast<remove_reference_t<T> const &&>(rhs);
}

// cast to T & -- non-const reference
template <typename T, enable_if_t<(!is_const<remove_reference_t<T>>::value),int> = 0>
static constexpr remove_reference_t<T> &
ref(T && object) noexcept
{
	return static_cast<remove_reference_t<T> &>(object);
}

// cast to T const & -- const reference
template <typename T>
static constexpr remove_reference_t<T> const &
cref(T && object) noexcept
{
	return static_cast<remove_reference_t<T> const &>(object);
}

template <typename T, enable_if_t<has_swap<T>::value,int> = 0>
static constexpr void
swap(T & lhs, T & rhs) noexcept
{
	lhs.swap(rhs);
}

template <typename T, enable_if_t<
		   !has_swap<T>::value 
		&& is_move_constructible<remove_cvref_t<T>>::value
		&& is_move_assignable<remove_cvref_t<T>>::value
		,int> = 0>
static constexpr void
swap(T & lhs, T & rhs) noexcept
{
	T tmp = ds::move(lhs);
	lhs   = ds::move(rhs);
	rhs   = ds::move(tmp);
}

template <typename T, enable_if_t<!has_swap<T>::value 
		&& (   is_trivially_copy_constructible<remove_cvref_t<T>>::value
			|| is_trivially_copy_assignable<remove_cvref_t<T>>::value)
	,int> = 0>
static constexpr void
swap(T & lhs, T & rhs) noexcept
{
	T tmp = lhs;
	lhs   = rhs;
	rhs   = tmp;
}

template <typename E>
static constexpr void
swap(array_ptr_t<E> & lhs, array_ptr_t<E> & rhs) noexcept
{
	array_ptr_t<E> tmp = lhs;
	lhs = rhs;
	rhs = tmp;
}

template <typename E, size_t size_>
static constexpr void
swap(fixed_ptr_t<size_,E> & lhs, fixed_ptr_t<size_,E> & rhs) noexcept
{
	fixed_ptr_t<size_,E> tmp = lhs;
	lhs = rhs;
	rhs = tmp;
}

template <typename T>
static constexpr void
swap(T const & lhs, T const & rhs) noexcept = delete;

template <typename T, bool = is_destructible<T>::value && !is_trivially_destructible<T>::value>
struct safe_destructor
{
	static constexpr void destruct(T & object) { object.~T(); }
};

template <typename T>
struct safe_destructor<T,false>
{
	static constexpr void destruct(T & object) {}
};

template <typename T>
static constexpr void
destruct(T & object)
{
	return safe_destructor<T>::destruct(object);
}

template <typename T, typename... Args, enable_if_t<is_constructible<T,Args...>::value,int> = 0>
static inline T *
construct_at(void * addr, Args &&... args)
{
	return new (addr) T(ds::forward<Args>(args)...);
}

template <typename T, typename... Args, enable_if_t<is_constructible<T,Args...>::value,int> = 0>
static inline T *
construct_at_safe(void * addr, Args &&... args)
{
	return addr == nullptr 
		? nullptr 
		: new (addr) T(ds::forward<Args>(args)...);
}


template <typename T, typename S = T>
struct sequence
{
	T value = 0;
	S step  = 1;

	constexpr sequence() = default;

	constexpr sequence(T start_)
		: value { ds::move(start_) }
	{}

	constexpr sequence(T start_, S step_)
		: value { ds::move(start_) }
		, step  { ds::move(step_)  }
	{}

	constexpr operator T () noexcept 
	{
		auto next_ = value;
		value += step;
		return next_;
	}

};


struct Flush
{
	FILE * _file = nullptr;
};

static thread_local Flush flush { stdout };

struct Endl
{
	FILE * _file = nullptr;
};

static thread_local Endl endl { stdout };


static constexpr size_t 
string_length(char const * pstring_) noexcept
{
	size_t length_ = 0;
	for(; pstring_[length_] != '\0'; ++length_);
	return length_;
}

static constexpr size_t 
string_length(char const * pstring_, size_t max_) noexcept
{
	size_t length_ = 0;
	for(; length_ < max_ && pstring_[length_++] != '\0'; ++length_);
	return length_;
}


static constexpr int
string_compare(char const * lhs, char const * rhs) noexcept
{
	size_t i = 0;
	for(; lhs[i] != '\0' && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return lhs[i] == rhs[i]
		? 0 
		: rhs[i] != '\0'
			? -1 
				: lhs[i] != '\0';
}

static constexpr int
string_compare(char const * lhs, char const * rhs, size_t size_) noexcept
{
	size_t i = 0;
	for(; i < size_ && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return i == size_ && rhs[i] == '\0' 
		? 0
		: rhs[i] != '\0' 
			? -1 
			: i != size_;
}

static constexpr int
string_compare(char const * lhs, char const * rhs, size_t lsize, size_t rsize) noexcept
{
	size_t i = 0;
	for(; i < lsize && i < rsize; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return i == lsize && i == rsize
		? 0
		: i == lsize
			? -1 
			: i == rsize;
}

static constexpr int
string_partial_compare(char const * lhs, char const * rhs) noexcept
{
	size_t i = 0;
	for(; lhs[i] != '\0' && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return 0;
}

static constexpr int
string_partial_compare(char const * lhs, char const * rhs, size_t size_) noexcept
{
	size_t i = 0;
	for(; i < size_ && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return 0;
}

static constexpr int
string_partial_compare(char const * lhs, char const * rhs, size_t lsize, size_t rsize) noexcept
{
	return string_partial_compare(lhs, rhs, min(lsize, rsize));
}

template <typename E, size_t size_>
static constexpr size_t size(E (& array_)[size_]) { return size_; }

template <typename E, size_t size_>
static constexpr size_t size(E const (& array_)[size_]) { return size_; }


template <typename E, size_t size_>
static constexpr E * begin(E (& array_)[size_]) { return &array_[0]; }

template <typename E, size_t size_>
static constexpr E * end(E (& array_)[size_]) { return &array_[size_]; }

template <typename E, size_t size_>
static constexpr E const * begin(E const (& array_)[size_]) { return &array_[0]; }

template <typename E, size_t size_>
static constexpr E const * end(E const (& array_)[size_]) { return &array_[size_]; }


template <class C, typename sz_t = decltype(decl<C &>().size())>
static constexpr sz_t size(C & object_) { return object_.size(); }

template <class C, typename sz_t = decltype(decl<C const &>().size())>
static constexpr sz_t size(C const & object_) { return object_.size(); }


template <class C, typename it_t = decltype(decl<C &>().begin())>
static constexpr it_t begin(C & object_) { return object_.begin(); }

template <class C, typename it_t = decltype(decl<C &>().end())>
static constexpr it_t end(C & object_) { return object_.end(); }

template <class C, typename it_t = decltype(decl<C const &>().begin())>
static constexpr it_t begin(C const & object_) { return object_.begin(); }

template <class C, typename it_t = decltype(decl<C const &>().end())>
static constexpr it_t end(C const & object_) { return object_.end(); }


template <class C, typename it_t = decltype(decl<C &>().rbegin())>
static constexpr it_t rbegin(C & object_) { return object_.rbegin(); }

template <class C, typename it_t = decltype(decl<C &>().rend())>
static constexpr it_t rend(C & object_) { return object_.rend(); }

template <class C, typename it_t = decltype(decl<C const &>().rbegin())>
static constexpr it_t rbegin(C const & object_) { return object_.rbegin(); }

template <class C, typename it_t = decltype(decl<C const &>().rend())>
static constexpr it_t rend(C const & object_) { return object_.rend(); }


namespace traits {

template <typename T>
struct iterable;

} // namespace traits

template <class C, typename E>
struct inserter
{
	// C & container;
	// bool init(size_t required_size);
	// template <typename T>
	// bool insert(T && object);
};

namespace _ {
	template <class C, typename E, typename = decltype(decl<ds::inserter<C,E>>().insert(decl<E>()))>
	true_type has_inserter(int);
	template <class C, typename E>
	false_type has_inserter(...);
} // namespace _

template <class C, typename E>
struct has_inserter : decltype(_::has_inserter<C,E>(0)) {};

template <class C, typename E = typename traits::iterable<C>::element_t>
using inserter_t = conditional_t<has_inserter<remove_reference_t<C>,E>::value
		, ds::inserter<C,E>
		, void
	>;


template <typename K, typename V>
struct Entry
{
	K const key   {};
	V       value {};

	constexpr Entry() = default;
	constexpr Entry(Entry &&) = default;
	constexpr Entry(Entry const &) = default;
	Entry & operator=(Entry &&) = default;
	Entry & operator=(Entry const &) = default;

	template <typename K_ = K, enable_if_t<is_constructible<K,K_>::value,int> = 0>
	constexpr explicit Entry(K_ && key_)
		: key   { ds::forward<K_>(key_) }
	{}

	template <typename K_ = K, typename V_ = V
			, enable_if_t<is_constructible<K,K_>::value,int> = 0
			, enable_if_t<is_constructible<V,V_>::value,int> = 0>
	constexpr Entry(K_ && key_, V_ && value_)
		: key   { ds::forward<K_>(key_) }
		, value { ds::forward<V_>(value_) }
	{}

	template <typename = decltype(decl<K>() == decl<K>())>
	constexpr bool 
	operator==(Entry const & rhs) const noexcept
	{ return key == rhs.key; }

	template <typename = decltype(decl<K>() == decl<K>())>
	constexpr bool 
	operator==(K const & key_) const noexcept
	{ return key == key_; }

	template <typename T, typename = decltype(decl<K>() == decl<T>())>
	constexpr bool 
	operator==(T && key_) const noexcept
	{ return key == key_; }

	template <typename = decltype(decl<K>() < decl<K>())>
	constexpr bool 
	operator<(Entry const & rhs) const noexcept
	{ return key < rhs.key; }

	template <typename = decltype(decl<K>() < decl<K>())>
	constexpr bool 
	operator<(K const & key_) const noexcept
	{ return key < key_; }

	template <typename T, typename = decltype(decl<K>() < decl<T>())>
	constexpr bool 
	operator<(T && key_) const noexcept
	{ return key < key_; }

};

template <typename K, typename V>
struct Hasher<Entry<K,V>>
{
	static inline size_t hash(Entry<K,V> const & s) { return Hasher<K>::hash(s.key); }
	static inline size_t hash(K const & key) { return Hasher<K>::hash(key); }
	template <typename T, typename = decltype(Hasher<K>::hash(decl<T>()))>
	static inline size_t hash(T && key) { return Hasher<K>::hash(key); }
};

template <typename K, typename V>
struct OrderedHasher<Entry<K,V>> : integral_constant<size_t,OrderedHasher<K>::value>
{
	static inline size_t hash(Entry<K,V> const & s) { return OrderedHasher<K>::hash(s.key); }
	static inline size_t hash(K const & key) { return OrderedHasher<K>::hash(key); }
	template <typename T, typename = decltype(OrderedHasher<K>::hash(decl<T>()))>
	static inline size_t hash(T && key) { return OrderedHasher<K>::hash(key); }
};

template <typename K, typename V>
using entry = Entry<K,V>;

static thread_local char const * stream_separator = ", ";
static thread_local char const * stream_separator_key_value = ": ";

template <class OST, typename K, typename V
		, enable_if_t<is_out_streamable<OST,K>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,V>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,char const *>::value,int> = 0
	>
static inline OST & 
operator<<(OST & ost, ds::Entry<K,V> const & rhs)
{
	return ost << rhs.key << stream_separator_key_value << rhs.value;
}


template <class OST, typename C
		, typename IT = decltype(decl<C const &>().begin())
		, typename ET = decltype(*decl<IT &>())
		, typename    = decltype(decl<C const &>().end())
		, typename    = decltype(++decl<IT &>())
		, enable_if_t<is_out_streamable<OST,ET>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,char const *>::value,int> = 0
	>
static inline OST & 
operator<<(OST & ost, C const & rhs)
{
	auto end_ = rhs.end();
	for(auto it = rhs.begin();;)
	{
		ost << *it;
		if(++it != end_)
			ost << stream_separator;
		else 
			break;
	}
	return ost;
}

enum class duplicate_rule
{
	Default   = 1, // same as Allow.
	Allow     = 1, // Allow duplicates.
	Unique    = 2, // No duplicates but no replacing.
	Replace   = 3, // Replace duplicates.
};

// returns the upper-case hexadecimal representation of 'value' 0-F
// truncates on overflow to max. i.e. F
static constexpr char
hex_char(uint8_t value) 
{
	return value <= 9 ? ('0' + value) : (value <= 15 ? ('A' + value - 10) : 'F');
}

// returns the lower-case hexadecimal representation of 'value' 0-f
// truncates on overflow to max. i.e. f
static constexpr char
hex_char_lower(uint8_t value) 
{
	return value <= 9 ? ('0' + value) : (value <= 15 ? ('a' + value - 10) : 'f');
}

// returns the base-10 value of 'hex_char' which is expected to be a hexadecimal ([0-F]|[0-f])
// returns 0 on invalid input
static constexpr uint8_t  
hex_value(char hex_char) 
{
	if(hex_char >= '0' && hex_char <= '9')
		return uint8_t(hex_char - '0');
	else if(hex_char >= 'a' && hex_char <= 'f')
		return 10 + uint8_t(hex_char - 'a');
	else if(hex_char >= 'A' && hex_char <= 'F')
		return 10 + uint8_t(hex_char - 'A');
	else
		return 0;
}

// efficient reverse.
template<typename It> 
static constexpr void
reverse(It begin_, It end_)
{
	if(begin_ == end_)
		return;
	while(begin_ != --end_)
	{
		ds::swap(*begin_, *end_);
		if(++begin_ == end_)
			break;
	}
}

// efficient reverse.
template <typename T
		, typename = decltype(begin(decl<T>()))
		, typename = decltype(end(decl<T>()))
	>
static constexpr void
reverse(T && f_iterable)
{
	ds::reverse(ds::begin(f_iterable), ds::end(f_iterable));
}

namespace _ {

	template <typename E, class C>
	static constexpr void
	sort2(E & a, E & b, C && compare)
	{
		if(compare(b, a))
			ds::swap(a, b);
	}

	template <typename E, class C>
	static constexpr void
	sort3(E & a, E & b, E & c, C && compare)
	{
		if(compare(a, b))
		{
			if(compare(a, c))
			{
				if(compare(c, b))
					ds::swap(b, c);
			}
			else
			{
				swap(a, b);
				swap(a, c);
			}
		}
		else
		{
			if(compare(a, c))
			{
				ds::swap(a, b);
			}
			else
			{
				ds::swap(a, c);
				if(compare(b, a))
					ds::swap(a, b);
			}
		}
	}

	template <typename E, class C>
	static constexpr void
	sort4(E & a, E & b, E & c, E & d, C && compare)
	{
		if(compare(a, b))
		{
			if(compare(a, c))
			{
				if(compare(a, d))
				{
					sort3(b, c, d, compare);
				}
				else
				{
					swap(a, d);
					sort3(b, c, d, compare);
				}
			}
			else
			{
				if(compare(d, c))
				{
					swap(a, d);
					sort3(b, c, d, compare);
				}
				else
				{
					swap(a, c);
					sort3(b, c, d, compare);
				}
			}
		}
		else
		{
			if(compare(b, c))
			{
				if(compare(b, d))
				{
					swap(a, b);
					sort3(b, c, d, compare);
				}
				else
				{
					swap(a, d);
					sort3(b, c, d, compare);
				}
			}
			else
			{
				if(compare(d, c))
				{
					swap(a, d);
					sort3(b, c, d, compare);
				}
				else
				{
					swap(a, c);
					sort3(b, c, d, compare);
				}
			}
		}
	}

} // namespace _

// a very fast quick sort.
template<typename It, class C = less<decltype(*decl<It &>())>
		, enable_if_t<is_integral<decltype(decl<It &>() - decl<It &>())>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() < decl<It &>()),bool>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() - size_t(1)),It>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() + size_t(1)),It>::value,int> = 0
	> 
static constexpr void 
sort(It begin_, It end_, C && compare = {}) noexcept
{
	if(begin_ + 1 < end_)
	{
		auto size_ = size_t(end_ - begin_);
		if(size_ == 2)
			_::sort2(*begin_, *(begin_+1), compare);
		else if(size_ == 3)
			_::sort3(*begin_, *(begin_+1), *(begin_+2), compare);
		else if(size_ == 4)
			_::sort4(*begin_, *(begin_+1), *(begin_+2), *(begin_+3), compare);
		else 
		{
			// check if sorted
			{
				auto last_ = end_ - 1;
				bool sorted         = true;
				bool reverse_sorted = true;
				for(It it = begin_; it < last_; ++it)
				{
					if(sorted && compare(*(it+1), *it))
					{
						sorted = false;
						if(!reverse_sorted)
							break;
					}
					else if(reverse_sorted && compare(*it, *(it+1)))
					{
						reverse_sorted = false;
						if(!sorted)
							break;
					}
				}
				if(sorted)
					return;
				else if(reverse_sorted)
				{
					ds::reverse(begin_, end_);
					return;
				}
			}
			// sort
			{
				It pivot = begin_;
				It left  = begin_ + 1;
				It right = end_ - 1;
				while(left < right)
				{
					while(left < right && compare(*left, *pivot))
						++left;
					while(left <= right && !compare(*right, *pivot))
						--right;
					if(left < right)
					{
						ds::swap(*left, *right);
						++left;
						--right;
					}
				}
				if(right != pivot)
				{
					if(compare(*left, *pivot))
						ds::swap(*pivot, *left);
					else
						ds::swap(*pivot, *(--left));
				}
				else
					--left;
				ds::sort(begin_, left, compare);
				ds::sort(left + 1, end_, compare);
			}
		}
	}
}


// a very fast quick sort.
template <typename T, class C = less<decltype(*decl<T &>().begin())>
		, typename = decltype(size(decl<T>()))
		, typename = decltype(begin(decl<T>()))
		, typename = decltype(rbegin(decl<T>()))
	>
static constexpr void
sort(T && fr_iterable, C && compare = {})
{
	ds::sort(begin(fr_iterable), end(fr_iterable), ds::forward<C>(compare));
}


template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(begin(decl<T const &>()))
		, typename UB = decltype(begin(decl<U const &>()))
		, typename    = decltype(end(decl<T const &>()))
		, typename    = decltype(end(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(++decl<TB &>())
		, typename    = decltype(++decl<UB &>())
	>
static constexpr bool
begins_with(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lit = begin(lhs);
	auto ren = end(rhs);
	for(auto rit = begin(rhs); rit != ren; ++rit, ++lit)
		if(*rit != *lit)
			return false;
	return true;
}

template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(rbegin(decl<T const &>()))
		, typename UB = decltype(rbegin(decl<U const &>()))
		, typename    = decltype(rend(decl<T const &>()))
		, typename    = decltype(rend(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(--decl<TB &>())
		, typename    = decltype(--decl<UB &>())
	>
static constexpr bool
ends_with(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lit = rbegin(lhs);
	auto ren = rend(rhs);
	for(auto rit = rbegin(rhs); rit != ren; --rit, --lit)
		if(*rit != *lit)
			return false;
	return true;
}

template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(begin(decl<T const &>()))
		, typename UB = decltype(begin(decl<U const &>()))
		, typename    = decltype(end(decl<T const &>()))
		, typename    = decltype(end(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(++decl<TB &>())
		, typename    = decltype(++decl<UB &>())
	>
static constexpr bool
contians(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lend = end(lhs);
	auto rend = end(rhs);
	for(auto lit = begin(lhs); lit != lend; ++lit)
	{
		bool match_ = true;
		auto lit2 = lit;
		for(auto rit = begin(rhs); rit != rend; ++rit, ++lit2) 
			if(*lit2 != *rit)
				match_ = false;
		if(match_)
			return true;
	}
	return false;
}

template <size_t lsize_, size_t rsize_>
static constexpr bool
contians(char const (& lhs)[lsize_], char const (& rhs)[rsize_]) noexcept
{
	size_t lsize = lsize_ - 1;
	size_t rsize = rsize_ - 1;
	if(lsize < rsize)
		return false;
	auto lend = &lhs[lsize];
	auto rend = &rhs[rsize];
	for(auto lit = &lhs[0]; lit != lend; ++lit)
	{
		bool match_ = true;
		auto lit2 = lit;
		for(auto rit = &rhs[0]; rit != rend; ++rit, ++lit2) 
			if(*lit2 != *rit)
				match_ = false;
		if(match_)
			return true;
	}
	return false;
}

} // namespace ds

#endif // DS_COMMON
