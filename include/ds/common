#pragma once
#ifndef DS_COMMON
#define DS_COMMON

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cstdio>
#include <ctime>
#include <cmath>
#include <cassert>
#include <exception>
#include <new>
#include "macros"

#ifdef min
#	undef min
#endif
#ifdef max
#	undef max
#endif

namespace ds {

static constexpr struct Version { int major, minor, patch; } version { 0, 30, 115 };

#if DS_Cxx_Version <= DS_Cxx_Version_17 && !defined(__cpp_char8_t)
using char8_t = unsigned char;
#else
using char8_t = ::char8_t;
#endif

using exception = std::exception;
using bad_alloc = std::bad_alloc;
using nothrow_t = std::nothrow_t;
using nullptr_t = std::nullptr_t;
using std::nothrow;
using byte_t       = unsigned char;
using align_t      = size_t;
using byte_ptr_t   = byte_t *;
using byte_cptr_t  = byte_t const *;
using max_align_t  = std::max_align_t;

template <size_t size_, typename T> using fixed_ref_t  = T (&)[size_];
template <size_t size_, typename T> using fixed_cref_t = T const (&)[size_];
template <size_t size_, typename T> using fixed_ptr_t  = T (*)[size_];
template <size_t size_, typename T> using fixed_cptr_t = T const (*)[size_];

template <typename E> using array_ref_t  = E (&)[];
template <typename E> using array_cref_t = E const (&)[];
template <typename E> using array_ptr_t  = E (*)[];
template <typename E> using array_cptr_t = E const (*)[];

struct init_t {};

struct noinit_t {};

template <typename T>
struct inplace {};

template <typename T>
struct make {};

static constexpr init_t   init {};
static constexpr noinit_t noinit {};
static constexpr double   nanf   = float(__builtin_nan("0"));
static constexpr double   nan    = double(__builtin_nan("0"));
#if defined(__GNUC__)
static constexpr double   inff   = float(__builtin_inf());
static constexpr double   inf    = double(__builtin_inf());
#else
static constexpr double   inff   = float(1e300 * 1e300);
static constexpr double   inf    = double(1e300 * 1e300);
#endif

namespace _ {
	static constexpr uint32_t _endian_test_u32  = uint32_t(0x01020304);
	static constexpr uint8_t  _endian_test_byte = static_cast<uint8_t const &>(_endian_test_u32);
} // namespace _

static constexpr bool big_endian    = _::_endian_test_byte == 0x01;
static constexpr bool little_endian = _::_endian_test_byte == 0x04;
static constexpr bool middle_endian = _::_endian_test_byte == 0x02;
static_assert(big_endian || little_endian || middle_endian,  "unknown endian");

namespace _ {
	template <typename T, size_t = sizeof(T)>
	struct _to_bige
	{};

	template <typename T>
	struct _to_bige<T,1>
	{
		static constexpr T
		convert(T value)
		{
			return value;
		}
	};

	template <typename T>
	struct _to_bige<T,2>
	{
		static constexpr T
		convert(T value)
		{
			return big_endian
				? value
				: (
					  ((value & 0x00FF) << 8)
					| ((value & 0xFF00) >> 8)
				  );
		}
	};

	template <typename T>
	struct _to_bige<T,4>
	{
		static constexpr T
		convert(T value)
		{
			return big_endian 
				? value
				: little_endian 
					? (
						  ((value & 0x000000FF) << 24)
						| ((value & 0x0000FF00) << 8)
						| ((value & 0x00FF0000) >> 8)
						| ((value & 0xFF000000) >> 24)
					  )
					: (
						  ((value & 0x00FF0000) << 8)
						| ((value & 0xFF000000) >> 8)
						| ((value & 0x000000FF) << 8)
						| ((value & 0x0000FF00) >> 8)
					  );
		}
	};

	template <typename T>
	struct _to_bige<T,8>
	{
		static constexpr T
		convert(T value)
		{
			return big_endian 
				? value
				: little_endian 
					? (
						  ((value & 0x00000000000000FF) << 56)
						| ((value & 0x000000000000FF00) << 40)
						| ((value & 0x0000000000FF0000) << 24)
						| ((value & 0x00000000FF000000) << 8)
						| ((value & 0x000000FF00000000) >> 8)
						| ((value & 0x0000FF0000000000) >> 24)
						| ((value & 0x00FF000000000000) >> 40)
						| ((value & 0xFF00000000000000) >> 56)
					  )
					: (
						  ((value & 0x00FF000000000000) << 8)
						| ((value & 0xFF00000000000000) >> 8)
						| ((value & 0x000000FF00000000) << 8)
						| ((value & 0x0000FF0000000000) >> 8)
						| ((value & 0x0000000000FF0000) << 8)
						| ((value & 0x00000000FF000000) >> 8)
						| ((value & 0x00000000000000FF) << 8)
						| ((value & 0x000000000000FF00) >> 8)
					  );
		}
	};
} // namespace _

template <typename T>
static constexpr T
to_big_endian(T value)
{
	return _::_to_bige<T>::convert(value);
}

template <typename T>
static constexpr T
to_native_endian(T value)
{
	return _::_to_bige<T>::convert(value);
}

template <typename T> static constexpr T decl();

template <typename T>
struct type_identity
{
	using type = T;
};

template <typename T, T value_>
struct integral_constant
{
	static constexpr T value = value_;
	constexpr integral_constant() = default;
	constexpr T operator()() const noexcept { return value; };
	constexpr operator T() const noexcept { return value; };
};
template <typename T, T value_> constexpr T integral_constant<T,value_>::value;

template <bool value_>
using bool_constant = integral_constant<bool,value_>;

using false_type = bool_constant<false>;
using true_type  = bool_constant<true>;

template <typename T> struct add_pointer       : type_identity<T *> {};
template <typename T> struct add_pointer<T &>  : type_identity<T *> {};
template <typename T> struct add_pointer<T &&> : type_identity<T *> {};
template <typename T> using  add_pointer_t = typename add_pointer<T>::type;

template <typename T> struct add_lvalue_reference       : type_identity<T &> {};
template <typename T> struct add_lvalue_reference<T &>  : type_identity<T &> {};
template <typename T> struct add_lvalue_reference<T &&> : type_identity<T &> {};
template <typename T> using  add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template <typename T> struct add_rvalue_reference       : type_identity<T &&> {};
template <typename T> struct add_rvalue_reference<T &>  : type_identity<T &&> {};
template <typename T> struct add_rvalue_reference<T &&> : type_identity<T &&> {};
template <typename T> using  add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

template <typename T> struct remove_cv                   : type_identity<T> {};
template <typename T> struct remove_cv<T const>          : type_identity<T> {};
template <typename T> struct remove_cv<T volatile>       : type_identity<T> {};
template <typename T> struct remove_cv<T const volatile> : type_identity<T> {};
template <typename T> using  remove_cv_t = typename remove_cv<T>::type;

template <typename T> struct remove_reference       : type_identity<T> {};
template <typename T> struct remove_reference<T &>  : type_identity<T> {};
template <typename T> struct remove_reference<T &&> : type_identity<T> {};
template <typename T> using  remove_reference_t = typename remove_reference<T>::type;

template <typename T> using  remove_cvref_t     = remove_cv_t<remove_reference_t<T>>;

template <typename T> struct remove_pointer                     : type_identity<T> {};
template <typename T> struct remove_pointer<T *>                : type_identity<T> {};
template <typename T> struct remove_pointer<T * const>          : type_identity<T> {};
template <typename T> struct remove_pointer<T * volatile>       : type_identity<T> {};
template <typename T> struct remove_pointer<T * const volatile> : type_identity<T> {};
template <typename T> using  remove_pointer_t = typename remove_pointer<T>::type;

template <typename T> struct remove_pointer_cv : type_identity<add_pointer_t<remove_cv_t<remove_pointer_t<T>>>> {};
template <typename T> using  remove_pointer_cv_t = typename remove_pointer_cv<T>::type;

template <typename T> struct base_type : type_identity<remove_cv_t<remove_pointer_t<remove_cvref_t<T>>>> {}; 
template <typename T> using  base_type_t = typename base_type<T>::type;

namespace _ {
	template <typename From, typename To> struct _copy_reference             : type_identity<To> {};
	template <typename From, typename To> struct _copy_reference<From &,To>  : type_identity<To &> {};
	template <typename From, typename To> struct _copy_reference<From &&,To> : type_identity<To &&> {};
} // namespace _

template <typename From, typename To> struct copy_reference : _::_copy_reference<From,remove_reference_t<To>> {};
template <typename From, typename To> using  copy_reference_t = typename copy_reference<From,To>::type;
template <typename From, typename To> using  copy_ref_t       = typename copy_reference<From,To>::type;

namespace _ {
	template <typename From, typename To> struct _copy_cv                         : type_identity<To> {};
	template <typename From, typename To> struct _copy_cv<From const,To>          : type_identity<To const> {};
	template <typename From, typename To> struct _copy_cv<From volatile,To>       : type_identity<To volatile> {};
	template <typename From, typename To> struct _copy_cv<From const volatile,To> : type_identity<To const volatile> {};
} // namespace _

template <typename From, typename To> struct copy_cv : type_identity<
		copy_reference_t<To,typename _::_copy_cv<remove_reference_t<From>,remove_reference_t<To>>::type>
	> 
{};
template <typename From, typename To> using  copy_cv_t = typename copy_cv<From,To>::type;

template <bool condition_, typename T> struct enable_if {};
template <typename T>                  struct enable_if<true,T> : type_identity<T> {};
template <bool condition_, typename T> using  enable_if_t = typename enable_if<condition_,T>::type;

template <bool condition_, typename T, typename F> struct conditional           : type_identity<F> {};
template <typename T, typename F>                  struct conditional<true,T,F> : type_identity<T> {};
template <bool condition_, typename T, typename F> using  conditional_t = typename conditional<condition_,T,F>::type;

template <typename... Ts> struct are_all_true : false_type {};

namespace _ {
	template <typename T, bool = T::value, typename... Ts> struct _are_all_true                : false_type {};
	template <typename T>                                  struct _are_all_true<T,true>        : bool_constant<T::value> {};
	template <typename T, typename... Ts>                  struct _are_all_true<T,true,Ts...>  : bool_constant<are_all_true<Ts...>::value> {};
	template <typename T, typename... Ts>                  struct _are_all_true<T,false,Ts...> : false_type {};
} // namespace _

template <typename T, typename... Ts> struct are_all_true<T,Ts...> : bool_constant<_::_are_all_true<T,T::value,Ts...>::value> {};
template <>                           struct are_all_true<>        : true_type {};

template <typename... Ts> struct are_all_false : false_type {};

namespace _ {
	template <typename T, bool = T::value, typename... Ts> struct _are_all_false                : false_type {};
	template <typename T>                                  struct _are_all_false<T,false>       : bool_constant<!T::value> {};
	template <typename T, typename... Ts>                  struct _are_all_false<T,false,Ts...> : bool_constant<are_all_false<Ts...>::value> {};
	template <typename T, typename... Ts>                  struct _are_all_false<T,true,Ts...>  : false_type {};
} // namespace _

template <typename T, typename... Ts> struct are_all_false<T,Ts...> : bool_constant<_::_are_all_false<T,T::value,Ts...>::value> {};
template <>                           struct are_all_false<>        : true_type {};

template <typename T, typename U> struct is_same      : false_type {};
template <typename T>             struct is_same<T,T> : true_type {};

template <typename T, typename... Ts>             struct is_type_in_pack            : false_type {};
template <typename T>                             struct is_type_in_pack<T>         : false_type {};
template <typename T, typename U, typename... Ts> struct is_type_in_pack<T,U,Ts...> : bool_constant<is_type_in_pack<T,Ts...>::value> {};
template <typename T, typename... Ts>             struct is_type_in_pack<T,T,Ts...> : true_type {};

template <typename T> struct is_const             : false_type {};
template <typename T> struct is_const<T const>    : true_type {};
template <typename T> struct is_const<T const &>  : true_type {};
template <typename T> struct is_const<T const &&> : true_type {};

template <typename T> struct is_reference       : false_type {};
template <typename T> struct is_reference<T &>  : true_type {};
template <typename T> struct is_reference<T &&> : true_type {};

namespace _ {
	template <typename T> struct _is_pointer      : false_type {};
	template <typename T> struct _is_pointer<T *> : true_type {};
} // namespace _

template <typename T> struct is_pointer : _::_is_pointer<remove_cv_t<T>> {};

template <typename T>               struct is_array           : false_type {};
template <typename T>               struct is_array<T[]>      : true_type {};
template <typename T, size_t size_> struct is_array<T[size_]> : true_type {};

template <typename T>
struct is_integral : bool_constant<
		is_type_in_pack<remove_cv_t<T>
			, bool
			, char, char8_t, char16_t, char32_t, wchar_t
			, signed char, unsigned char
			, signed short, unsigned short
			, signed int, unsigned int
			, signed long, unsigned long
			, signed long long, unsigned long long
		>::value
	>
{};

template <typename T>
struct is_floating_point : bool_constant<
		is_type_in_pack<remove_cv_t<T>
			, float
			, double
			, long double
		>::value
	>
{};

template <typename T> struct is_arithmetic : bool_constant<is_integral<T>::value || is_floating_point<T>::value> {}; 

template <typename T> struct is_enum       : bool_constant<__is_enum(T)>  {};

template <typename T>
struct is_scalar : bool_constant<
		   is_arithmetic<T>::value 
		|| is_enum<T>::value 
		|| is_pointer<T>::value 
		|| is_same<remove_cv_t<T>,nullptr_t>::value
	> 
{};

template <typename T> struct is_union      : bool_constant<__is_union(T)> {};

namespace _ {
	template <typename T> bool_constant<!is_union<T>::value> _class_test(int T::*);
	template <typename T> false_type                         _class_test(...);
} // namespace _

template <typename T> struct is_class    : decltype(_::_class_test<T>(nullptr)) {};

template <typename T>                   struct is_function             : false_type {};
template <typename R, typename... Args> struct is_function<R(Args...)> : true_type {};

template <typename T>          struct is_member_pointer         : false_type {};
template <typename T, class C> struct is_member_pointer<T C::*> : true_type {};

namespace _ {
	template <typename T>                            struct _is_member_object_pointer                                  : false_type {};
	template <typename T, class C>                   struct _is_member_object_pointer<T C::*>                          : true_type {};
	template <typename R, class C, typename... Args> struct _is_member_object_pointer<R(C::*)(Args...)>                : false_type {};
	template <typename R, class C, typename... Args> struct _is_member_object_pointer<R(C::*)(Args...) const>          : false_type {};
	template <typename R, class C, typename... Args> struct _is_member_object_pointer<R(C::*)(Args...) volatile>       : false_type {};
	template <typename R, class C, typename... Args> struct _is_member_object_pointer<R(C::*)(Args...) const volatile> : false_type {};
} // namespace _

template <typename T> struct is_member_object_pointer : bool_constant<_::_is_member_object_pointer<remove_cv_t<T>>::value> {};

namespace _ {
	template <typename T>                            struct _is_member_function_pointer                                  : false_type {};
	template <typename R, class C, typename... Args> struct _is_member_function_pointer<R(C::*)(Args...)>                : true_type {};
	template <typename R, class C, typename... Args> struct _is_member_function_pointer<R(C::*)(Args...) const>          : true_type {};
	template <typename R, class C, typename... Args> struct _is_member_function_pointer<R(C::*)(Args...) volatile>       : true_type {};
	template <typename R, class C, typename... Args> struct _is_member_function_pointer<R(C::*)(Args...) const volatile> : true_type {};
} // namespace _

template <typename T> struct is_member_function_pointer : bool_constant<_::_is_member_function_pointer<remove_cv_t<T>>::value> {};

namespace _ {
	template <typename T, typename... Args
			, typename = decltype(T{decl<Args>()...})
		> true_type  _test_aggregate_initializable(int);

	template <typename T, typename... Args> false_type _test_aggregate_initializable(...);
} // namespace _

template <typename T, typename... Args>
struct is_aggregate_initializable : decltype(_::_test_aggregate_initializable<T,Args...>(0)) {};

namespace _ {
	template <typename T
			, typename = decltype(decl<T &>().~T())
		> true_type  _test_destructible(int); 

	template <typename T> false_type _test_destructible(...); 
} // namespace _

template <typename T> struct is_destructible           : decltype(_::_test_destructible<T>(0)) {};

#if defined(__GNUC__) && !defined(__clang__)
template <typename T> struct is_trivially_destructible : bool_constant<is_destructible<T>::value && __has_trivial_destructor(T)> {};
#else
template <typename T> struct is_trivially_destructible : bool_constant<__is_trivially_destructible(T)> {};
#endif

template <typename T> struct is_virtually_destructible : bool_constant<is_destructible<T>::value && __has_virtual_destructor(T)> {};

namespace _ {
	template <typename From, typename To
			, typename = decltype(static_cast<To>(decl<From>()))
		> true_type _test_static_castable(int);

	template <typename From, typename To> false_type _test_static_castable(...);

	template <typename From, typename To
			, typename = decltype(dynamic_cast<To>(decl<From>()))
		> true_type _test_dynamic_castable(int);

	template <typename From, typename To>  false_type _test_dynamic_castable(...);

	template <typename T, typename... Args
			, typename = decltype(T(decl<Args>()...))
		> true_type _test_constructible(int);

	template <typename T, typename... Args> false_type _test_constructible(...);

	template <typename T, typename U
			, typename = decltype(decl<T &>() = decl<U>())
		> true_type _test_assignable(int);
	
	template <typename T, typename U> false_type _test_assignable(...);
}


template <typename From, typename To>   struct is_static_castable         : decltype(_::_test_static_castable<From,To>(0)) {};
template <typename From, typename To>   struct is_dynamic_castable        : decltype(_::_test_dynamic_castable<From,To>(0)) {};
template <typename T, typename... Args> struct is_constructible           : decltype(_::_test_constructible<T,Args...>(0)) {};
template <typename T, typename... Args> struct is_trivially_constructible : bool_constant<__is_trivially_constructible(T,Args...)> {};
template <typename T, typename U>       struct is_assignable              : decltype(_::_test_assignable<T,U>(0)) {};
template <typename T, typename U>       struct is_trivially_assignable    : bool_constant<__is_trivially_assignable(T,U)> {};

template <typename T> using is_copy_constructible           = is_constructible<T,remove_cvref_t<T> const &>;
template <typename T> using is_trivially_copy_constructible = is_trivially_constructible<T,remove_cvref_t<T> const &>;
template <typename T> using is_move_constructible           = is_constructible<T,remove_cvref_t<T> &&>;
template <typename T> using is_trivially_move_constructible = is_trivially_constructible<T,remove_cvref_t<T> &&>;
template <typename T> using is_copy_assignable              = is_assignable<T,remove_cvref_t<T> const &>;
template <typename T> using is_move_assignable              = is_assignable<T,remove_cvref_t<T> &&>;
template <typename T> using is_trivially_copy_assignable    = is_trivially_assignable<T,remove_cvref_t<T> const &>;
template <typename T> using is_trivially_move_assignable    = is_trivially_assignable<T,remove_cvref_t<T> &&>;

template <typename T> 
struct is_signed : bool_constant<bool(T(-1) < T(0))> {};

template <typename T> 
struct is_unsigned : bool_constant<bool(T(-1) > T(0))> {};

namespace _ {
	template <typename T>   struct _is_string                                 : false_type {};
	template <>             struct _is_string<char[]>                         : true_type {};
	template <size_t size_> struct _is_string<char[size_]>                    : true_type {};
	template <>             struct _is_string<char *>                         : true_type {};
	template <>             struct _is_string<char(*)[]>                      : true_type {};
	template <size_t size_> struct _is_string<char(*)[size_]>                 : true_type {};
} // namespace _

template <typename T>   struct is_string : _::_is_string<
		conditional_t<is_pointer<T>::value
			, remove_pointer_cv_t<T>
			, remove_cvref_t<T>
		>
	> 
{};

namespace _ {
	template <class OST, typename T
			, typename = decltype(decl<OST &>() >> decl<T const &>())
		> true_type is_in_streamable(int);
	template <class OST, typename T> false_type is_in_streamable(...);

	template <class OST, typename T
			, typename = decltype(decl<OST &>() << decl<T const &>())
		> true_type is_out_streamable(int);
	template <class OST, typename T> false_type is_out_streamable(...);
} // namespace _

template <class OST, typename T> struct is_in_streamable  : decltype(_::is_in_streamable<OST,T>(0)) {};
template <class OST, typename T> struct is_out_streamable : decltype(_::is_out_streamable<OST,T>(0)) {};


template <typename T>
static constexpr T const &
min(T const & lhs, T const & rhs) noexcept
{
	return lhs < rhs ? lhs : rhs;
}

template <typename T>
static constexpr T &
min(T & lhs, T & rhs) noexcept
{
	return lhs < rhs ? lhs : rhs;
}

template <typename T>
static constexpr T const &
max(T const & lhs, T const & rhs) noexcept
{
	return lhs > rhs ? lhs : rhs;
}

template <typename T>
static constexpr T &
max(T & lhs, T & rhs) noexcept
{
	return lhs > rhs ? lhs : rhs;
}

template <typename T>
static constexpr T 
abs(T const & rhs) noexcept
{
	return rhs < 0 ? -rhs : rhs;
}

template <typename T>
static DS_constexpr14 bool 
is_prime(T value) noexcept
{
	T N = value;
	for(T i = 2; i <= N; ++i, N /= i)
		if(value % i == 0)
			return false;
	return true;
}

template <typename T>
static DS_constexpr14 T 
next_prime(T value) noexcept
{
	while(!is_prime(++value));
	return value;
}

template <typename T>
static DS_constexpr14 T 
previous_prime(T value) noexcept
{
	while(!is_prime(--value));
	return value;
}

template <size_t size_, typename T>
static fixed_cref_t<size_,T>
gen_prime_squares() noexcept
{
	static T prime_squares[size_];
	T prime_ = 1;
	for(auto & e : prime_squares)
	{
		prime_ = next_prime<T>(prime_);
		e = prime_ * prime_;
	}
	return prime_squares;
}

template <size_t size_, typename T>
static fixed_cref_t<size_,T>
init_prime_squares() noexcept
{
	static auto & prime_squares = gen_prime_squares<size_,T>();
	return prime_squares;
}

template <typename T>                               struct usage    { static constexpr size_t value = 0; };
template <typename T, size_t count_>                struct usage_n  { static constexpr size_t value = 0; };
template <typename T, size_t size_>                 struct usage_s  { static constexpr size_t value = 0; };
template <typename T, size_t size_, size_t count_>  struct usage_sn { static constexpr size_t value = 0; };

template <typename T, bool is_signed = bool(T(-1) < T(0)), size_t = sizeof(T)> 
struct max_integral 
{};
template <typename T> struct max_integral<T,true,1>  : integral_constant<T,T(0x7F)> {};
template <typename T> struct max_integral<T,true,2>  : integral_constant<T,T(0x7FFF)> {};
template <typename T> struct max_integral<T,true,4>  : integral_constant<T,T(0x7FFFFFFF)> {};
template <typename T> struct max_integral<T,true,8>  : integral_constant<T,T(0x7FFFFFFFFFFFFFFF)> {};
template <typename T> struct max_integral<T,false,1> : integral_constant<T,T(0xFF)> {};
template <typename T> struct max_integral<T,false,2> : integral_constant<T,T(0xFFFF)> {};
template <typename T> struct max_integral<T,false,4> : integral_constant<T,T(0xFFFFFFFF)> {};
template <typename T> struct max_integral<T,false,8> : integral_constant<T,T(0xFFFFFFFFFFFFFFFF)> {};

template <typename T, bool is_signed = bool(T(-1) < T(0)), size_t = sizeof(T)> 
struct min_integral 
{};
template <typename T> struct min_integral<T,true,1>  : integral_constant<T,T(0x80)> {};
template <typename T> struct min_integral<T,true,2>  : integral_constant<T,T(0x8000)> {};
template <typename T> struct min_integral<T,true,4>  : integral_constant<T,T(0x80000000)> {};
template <typename T> struct min_integral<T,true,8>  : integral_constant<T,T(0x8000000000000000)> {};
template <typename T> struct min_integral<T,false,1> : integral_constant<T,T(0x0)> {};
template <typename T> struct min_integral<T,false,2> : integral_constant<T,T(0x0)> {};
template <typename T> struct min_integral<T,false,4> : integral_constant<T,T(0x0)> {};
template <typename T> struct min_integral<T,false,8> : integral_constant<T,T(0x0)> {};

template <typename T> 
struct max_floating_point 
{};
template <> struct max_floating_point<float>       { static constexpr float       value = 3.402823466e+38F; };
template <> struct max_floating_point<double>      { static constexpr double      value = 1.7976931348623158e+308; };
template <> struct max_floating_point<long double> { static constexpr long double value = 1.7976931348623158e+308L; };

template <typename T> 
struct min_floating_point 
{};
template <> struct min_floating_point<float>       { static constexpr float       value =-3.402823466e+38F; };
template <> struct min_floating_point<double>      { static constexpr double      value =-1.7976931348623158e+308; };
template <> struct min_floating_point<long double> { static constexpr long double value =-1.7976931348623158e+308L; };

template <typename T, int = (is_integral<T>::value ? 1 : (is_floating_point<T>::value ? 2 : 0))>
struct max_limit 
{};
template <typename T> struct max_limit<T,1> : max_integral<T> {};
template <typename T> struct max_limit<T,2> : max_floating_point<T> {};

template <typename T, int = (is_integral<T>::value ? 1 : (is_floating_point<T>::value ? 2 : 0))>
struct min_limit 
{};
template <typename T> struct min_limit<T,1> : min_integral<T> {};
template <typename T> struct min_limit<T,2> : min_floating_point<T> {};


template <typename T>
struct integral_index 
{};
template <> struct integral_index<signed char>            : integral_constant<size_t,0> {};
template <> struct integral_index<unsigned char>          : integral_constant<size_t,1> {};
template <> struct integral_index<signed short>           : integral_constant<size_t,2> {};
template <> struct integral_index<unsigned short>         : integral_constant<size_t,3> {};
template <> struct integral_index<signed long>            : integral_constant<size_t,4> {};
template <> struct integral_index<unsigned long>          : integral_constant<size_t,5> {};
template <> struct integral_index<signed long long>       : integral_constant<size_t,6> {};
template <> struct integral_index<unsigned long long>     : integral_constant<size_t,7> {};
template <> struct integral_index<signed int>             : integral_constant<size_t,8> {};
template <> struct integral_index<unsigned int>           : integral_constant<size_t,9> {};

template <typename T>
struct floating_point_index 
{};
template <> struct floating_point_index<float>       : integral_constant<size_t,0> {};
template <> struct floating_point_index<double>      : integral_constant<size_t,1> {};
template <> struct floating_point_index<long double> : integral_constant<size_t,2> {};

static constexpr char const * 
integral_format[]
{
	"%hhd", "%hhu", "%hd", "%hu", "%ld", "%lu", "%lld", "%llu", "%d", "%u"
};

static constexpr char const * 
floating_point_format[]
{
	"%f", "%lf", "%Lf"
};

static constexpr char const * 
floating_point_scientific_format[]
{
	"%e", "%le", "%Le"
};

static constexpr char const * 
floating_point_generic_format[]
{
	"%g", "%lg", "%Lg"
};

template<typename T> 
struct Hasher 
{};
template<> struct Hasher<bool>       { static constexpr size_t hash(bool value)     noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char>       { static constexpr size_t hash(char value)     noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char16_t>   { static constexpr size_t hash(char16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char32_t>   { static constexpr size_t hash(char32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<wchar_t>    { static constexpr size_t hash(wchar_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int8_t>     { static constexpr size_t hash(int8_t value)   noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint8_t>    { static constexpr size_t hash(uint8_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int16_t>    { static constexpr size_t hash(int16_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint16_t>   { static constexpr size_t hash(uint16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int32_t>    { static constexpr size_t hash(int32_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint32_t>   { static constexpr size_t hash(uint32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int64_t>    { static constexpr size_t hash(int64_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint64_t>   { static constexpr size_t hash(uint64_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<nullptr_t>  { static constexpr size_t hash(nullptr_t)      noexcept { return 0; } };
template<class T> struct Hasher<T *> { static inline    size_t hash(T const * ptr)  noexcept { return size_t(ptr); } };

template<size_t size_> 
struct Hasher<char[size_]>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		static constexpr size_t prime_sq_size = 512;
		auto const & prime_squares = init_prime_squares<prime_sq_size,size_t>();
		if(!pstring)
			return 0;
		size_t hash_ = 0;
		for(size_t i = 0; i < size_ && pstring[i] != '\0'; ++i)
			hash_ += size_t(pstring[i]) * prime_squares[i % prime_sq_size];
		return hash_;
	}

};

template <>
struct Hasher<char[]>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		static constexpr size_t prime_sq_size = 512;
		auto const & prime_squares = init_prime_squares<prime_sq_size,size_t>();
		if(!pstring)
			return 0;
		size_t hash_ = 0;
		for(size_t i = 0; pstring[i] != '\0'; ++i)
			hash_ += size_t(pstring[i]) * prime_squares[i % prime_sq_size];
		return hash_;
	}

};

template<typename T> using hasher = Hasher<T>;

template<typename T> 
struct OrderedHasher 
{};
template<> struct OrderedHasher<bool>        : integral_constant<size_t,max_integral<size_t,false,sizeof(bool)>::value> { static constexpr size_t hash(bool value)     noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char>        : integral_constant<size_t,max_integral<size_t,false,sizeof(char)>::value> { static constexpr size_t hash(char value)     noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char16_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(char16_t)>::value> { static constexpr size_t hash(char16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char32_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(char32_t)>::value> { static constexpr size_t hash(char32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<wchar_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(wchar_t)>::value> { static constexpr size_t hash(wchar_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int8_t>      : integral_constant<size_t,max_integral<size_t,false,sizeof(int8_t)>::value> { static constexpr size_t hash(int8_t value)   noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint8_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(uint8_t)>::value> { static constexpr size_t hash(uint8_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int16_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int16_t)>::value> { static constexpr size_t hash(int16_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint16_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint16_t)>::value> { static constexpr size_t hash(uint16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int32_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int32_t)>::value> { static constexpr size_t hash(int32_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint32_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint32_t)>::value> { static constexpr size_t hash(uint32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int64_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int64_t)>::value> { static constexpr size_t hash(int64_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint64_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint64_t)>::value> { static constexpr size_t hash(uint64_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<nullptr_t>   : integral_constant<size_t,max_integral<size_t>::value> { static constexpr size_t hash(nullptr_t)      noexcept { return 0; } };
template<class T> struct OrderedHasher<T *>  : integral_constant<size_t,max_integral<size_t>::value> { static inline    size_t hash(T const * ptr)  noexcept { return size_t(ptr); } };

template<size_t size_> 
struct OrderedHasher<char[size_]> : integral_constant<size_t,max_integral<size_t>::value>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		if(!pstring)
			return 0;
		size_t ordered_hash_ = 0;
		size_t min_size = min(sizeof(size_t), size_);
		for(size_t i = 0; i < min_size && pstring[i] != '\0'; ++i)
			ordered_hash_ |= size_t(pstring[i]) << ((sizeof(size_t) - i - 1) * 8);
		return ordered_hash_;
	}

};

template <>
struct OrderedHasher<char[]> : integral_constant<size_t,max_integral<size_t>::value>
{
	static size_t 
	hash(char const * pstring) noexcept
	{
		if(!pstring)
			return 0;
		size_t ordered_hash_ = 0;
		for(size_t i = 0; i < sizeof(size_t) && pstring[i] != '\0'; ++i)
			ordered_hash_ |= size_t(pstring[i]) << ((sizeof(size_t) - i - 1) * 8);
		return ordered_hash_;
	}

};

template<typename T> using ordered_hasher = OrderedHasher<T>;

namespace _ {
	template <typename T, typename E = T
			, typename = decltype(Hasher<E>::hash(decl<T>()))
		> true_type _test_hashable(int); 
	template <typename T, typename E = T> false_type is_hashable(...); 

	template <typename T, typename E = T
			, typename = decltype(OrderedHasher<E>::hash(decl<T>()))
		> true_type _test_ordered_hashable(int); 
	template <typename T, typename E = T> false_type is_ordered_hashable(...); 
} // namespace _

template <typename T, typename E = T> struct is_hashable         : decltype(_::_test_hashable<T,E>(0)) {};
template <typename T, typename E = T> struct is_ordered_hashable : decltype(_::_test_ordered_hashable<T,E>(0)) {};


template <typename T, T... sequence_>
struct integer_sequence 
{};

namespace _ {
	template <typename T, T start_, T end_, bool = (start_ < end_), T i_ = start_, T... sequence_>
	struct integer_sequence_maker 
	{};

	template <typename T, T start_>
	struct integer_sequence_maker<T,start_,start_,false,start_>
	{
		using type = integer_sequence<T>;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,start_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,true,start_+1,sequence_...,start_>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,i_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,true,i_+1,sequence_...,i_>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,start_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,false,start_-1,sequence_...,start_>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,i_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,false,i_-1,sequence_...,i_>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, bool = (start_ < end_), T i_ = start_, T... sequence_>
	struct reverse_integer_sequence_maker 
	{};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,start_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,true,start_+1,start_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,i_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,true,i_+1,i_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,start_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,false,start_-1,start_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,i_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,false,i_-1,i_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};
} // namespace _

template <typename T, T start_, T end_> using make_integer_sequence_t         = typename _::integer_sequence_maker<T,start_,end_>::type;
template <typename T, T start_, T end_> using make_reverse_integer_sequence_t = typename _::reverse_integer_sequence_maker<T,start_,end_>::type;
template <size_t... indices_>           using index_sequence                  = integer_sequence<size_t,indices_...>;
template <size_t start_, size_t end_>   using make_index_sequence_t           = typename _::integer_sequence_maker<size_t,start_,end_>::type;
template <size_t start_, size_t end_>   using make_reverse_index_sequence_t   = typename _::reverse_integer_sequence_maker<size_t,start_,end_>::type;


template <size_t index_, typename... Ts>             struct type_at_index                 : type_identity<void> {};
template <size_t index_, typename T, typename... Ts> struct type_at_index<index_,T,Ts...> : type_identity<typename type_at_index<index_-1,Ts...>::type> {};
template <typename T, typename... Ts>                struct type_at_index<0,T,Ts...>      : type_identity<T> {};
template <size_t index_, typename... Ts>             using  type_at_index_t = typename type_at_index<index_,Ts...>::type;


template <typename T, size_t start_ = 0, typename... Ts>         struct type_index                   : integral_constant<size_t,size_t(-1)> {};
template <typename T, size_t start_, typename U, typename... Ts> struct type_index<T,start_,U,Ts...> : integral_constant<size_t,type_index<T,start_+1,Ts...>::value> {};
template <typename T, size_t start_, typename... Ts>             struct type_index<T,start_,T,Ts...> : integral_constant<size_t,start_> {};


// equal to
template <typename L, typename R = L>
struct equal
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs == rhs; } };

// less than
template <typename L, typename R = L>
struct less
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs < rhs; } };

// greater than
template <typename L, typename R = L>
struct greater
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs > rhs; } };

// less than or equal to
template <typename T>
struct less_or_equal
{ constexpr bool operator() (T const & lhs, T const & rhs) const noexcept { return lhs <= rhs; } };

// greater than or equal to
template <typename L, typename R = L>
struct greater_or_equal
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs >= rhs; } };


/** 
 * forward cast a universal reference.
 * 
 * T __________ T &&
 * T const ____ T const &&
 * T & ________ T &
 * T const & __ T const &
 * T && _______ T &&
 * T const && _ T const &&
 * 
 */
template <typename T> 
DS_nodiscard static constexpr T && 
forward(remove_reference_t<T> & t) noexcept 
{ return static_cast<T &&>(t); }

// cast to T && -- non-const move
// ds::move does not support moving const types unlike std::move
template <typename T, enable_if_t<(!is_const<remove_reference_t<T>>::value),int> = 0>
DS_nodiscard static constexpr remove_reference_t<T> &&
move(T && rhs) noexcept
{
	return static_cast<remove_reference_t<T> &&>(rhs);
}

// cast to T const && -- const move
template <typename T, enable_if_t<(is_const<remove_reference_t<T>>::value),int> = 0>
DS_nodiscard static constexpr remove_reference_t<T> const &&
cmove(T && rhs) noexcept
{
	return static_cast<remove_reference_t<T> const &&>(rhs);
}

template <typename T>
static constexpr T
clone(T const & object)
{
	return object;
}

// cast to T & -- non-const reference
template <typename T, enable_if_t<(!is_const<remove_reference_t<T>>::value),int> = 0>
static constexpr remove_reference_t<T> &
ref(T && object) noexcept
{
	return static_cast<remove_reference_t<T> &>(object);
}

// cast to T const & -- const reference
template <typename T>
static constexpr remove_reference_t<T> const &
cref(T && object) noexcept
{
	return static_cast<remove_reference_t<T> const &>(object);
}

namespace _ {
	template <typename T
			, typename = decltype(decl<T &>().swap(decl<T &>()))
		> true_type  _has_swap(int);
	template <typename T> false_type _has_swap(...);
} // namespace _

template <typename T> struct has_swap : decltype(_::_has_swap<T>(0)) {};

namespace _ {
	template <typename T
			, bool = has_swap<remove_reference_t<T>>::value
			, bool = is_array<remove_reference_t<T>>::value
			, bool = is_pointer<remove_reference_t<T>>::value
			, bool = (is_move_constructible<remove_reference_t<T>>::value && is_move_assignable<remove_reference_t<T>>::value)
			, bool = (is_copy_constructible<remove_reference_t<T>>::value && is_copy_assignable<remove_reference_t<T>>::value)
		>
	struct _swapper
	{};

	template <typename T, bool b1, bool b2>
	struct _swapper<T,true,false,false,b1,b2>
	{
		static DS_constexpr14 void
		swap(T & lhs, T & rhs)
		{
			lhs.swap(rhs);
		}
	};

	template <typename T, bool b1, bool b2>
	struct _swapper<T,false,false,true,b1,b2>
	{
		static DS_constexpr14 void
		swap(T & lhs, T & rhs)
		{
			T tmp = lhs;
			lhs   = rhs;
			rhs   = tmp;
		}
	};

	template <typename T, bool b2>
	struct _swapper<T,false,false,false,true,b2>
	{
		static DS_constexpr14 void
		swap(T & lhs, T & rhs)
		{
			T tmp = ds::move(lhs);
			lhs   = ds::move(rhs);
			rhs   = ds::move(tmp);
		}
	};

	template <typename T>
	struct _swapper<T,false,false,false,false,true>
	{
		static DS_constexpr14 void
		swap(T & lhs, T & rhs)
		{
			T tmp = lhs;
			lhs   = rhs;
			rhs   = tmp;
		}
	};
} // namespace _


template <typename T
		, typename = decltype(_::_swapper<T>::swap(decl<T &>(), decl<T &>()))
	>
static DS_constexpr14 void
swap(T & lhs, T & rhs) noexcept
{
	_::_swapper<T>::swap(lhs, rhs);
}

template <typename T>
static DS_constexpr14 void
swap(T const & lhs, T const & rhs) noexcept = delete;

namespace _ {
	template <typename T
			, typename = decltype(ds::swap(decl<T &>(), decl<T &>()))
		> true_type  _is_swappable(int);
	template <typename T> false_type _is_swappable(...);
} // namespace _

template <typename T> struct is_swappable : decltype(_::_is_swappable<T>(0)) {};


static inline size_t
aligned_offset(void * block_, align_t align_)
{
	return (~size_t(block_)+1) & (--align_);
}


template <typename T, bool = is_destructible<T>::value && !is_trivially_destructible<T>::value>
struct safe_destructor
{
	static DS_constexpr14 void destruct(T & object) { object.~T(); }
};

template <typename T>
struct safe_destructor<T,false>
{
	static DS_constexpr14 void destruct(T & object) {}
};

template <typename T>
static DS_constexpr14 void
destruct(T & object)
{
	return safe_destructor<T>::destruct(object);
}

template <typename T, typename... Args, enable_if_t<is_constructible<T,Args...>::value,int> = 0>
static inline T *
construct_at(void * addr, Args &&... args)
{
	return new (addr) T(ds::forward<Args>(args)...);
}

template <typename T, typename... Args, enable_if_t<is_constructible<T,Args...>::value,int> = 0>
static inline T *
construct_at_safe(void * addr, Args &&... args)
{
	return addr == nullptr 
		? nullptr 
		: new (addr) T(ds::forward<Args>(args)...);
}

template <typename T, typename... Args, enable_if_t<is_aggregate_initializable<T,Args...>::value,int> = 0>
static inline T *
aggregate_init_at(void * addr, Args &&... args)
{
	return new (addr) T { ds::forward<Args>(args)... };
}

template <typename T, typename... Args, enable_if_t<is_aggregate_initializable<T,Args...>::value,int> = 0>
static inline T *
aggregate_init_at_safe(void * addr, Args &&... args)
{
	return addr == nullptr 
		? nullptr 
		: new (addr) T { ds::forward<Args>(args)... };
}

template <typename T, typename... Args
		, enable_if_t<is_aggregate_initializable<T,Args...>::value,int> = 0
	>
static inline T *
aggregate_init_or_construct_at(void * addr, Args &&... args)
{
	return new (addr) T { ds::forward<Args>(args)... };
}

template <typename T, typename... Args
		, enable_if_t<(!is_aggregate_initializable<T,Args...>::value
		             && is_constructible<T,Args...>::value)
			,int> = 0
	>
static inline T *
aggregate_init_or_construct_at(void * addr, Args &&... args)
{
	return new (addr) T(ds::forward<Args>(args)...);
}

template <typename T, typename... Args
		, enable_if_t<is_aggregate_initializable<T,Args...>::value,int> = 0
	>
static inline T *
aggregate_init_or_construct_at_safe(void * addr, Args &&... args)
{
	return addr == nullptr 
		? nullptr 
		: new (addr) T { ds::forward<Args>(args)... };
}

template <typename T, typename... Args
		, enable_if_t<(!is_aggregate_initializable<T,Args...>::value
		             && is_constructible<T,Args...>::value)
			,int> = 0
	>
static inline T *
aggregate_init_or_construct_at_safe(void * addr, Args &&... args)
{
	return addr == nullptr 
		? nullptr 
		: new (addr) T { ds::forward<Args>(args)... };
}


template <typename T, typename S = T>
struct Sequence
{
	T value = 0;
	S step  = 1;

	constexpr Sequence() = default;

	constexpr Sequence(T start_)
		: value { ds::move(start_) }
	{}

	constexpr Sequence(T start_, S step_)
		: value { ds::move(start_) }
		, step  { ds::move(step_)  }
	{}

	DS_constexpr14 operator T () noexcept 
	{
		auto next_ = value;
		value += step;
		return ds::move(next_);
	}

};

template <typename T> using sequence = Sequence<T>;

struct FlushTo
{
	FILE * _file = nullptr;

	FlushTo() = default;

	FlushTo(FILE * file_)
		: _file { file_ }
	{}

};

static thread_local FlushTo flush { stdout };

using flush_to = FlushTo; 

struct EndLine
{
	FILE * _file = nullptr;

	EndLine() = default;

	EndLine(FILE * file_)
		: _file { file_ }
	{}

};

static thread_local EndLine endl { stdout };

using end_line = EndLine;

static DS_constexpr14 size_t 
string_length(char const * pstring_) noexcept
{
	if(pstring_ == nullptr)
		return 0;
	size_t length_ = 0;
	for(; pstring_[length_] != '\0'; ++length_);
	return length_;
}

static DS_constexpr14 size_t 
string_length(char const * pstring_, size_t max_) noexcept
{
	if(pstring_ == nullptr)
		return 0;
	size_t length_ = 0;
	for(; length_ < max_ && pstring_[length_++] != '\0'; ++length_);
	return length_;
}


static DS_constexpr14 int
string_compare(char const * lhs, char const * rhs) noexcept
{
	size_t i = 0;
	for(; lhs[i] != '\0' && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return lhs[i] == rhs[i]
		? 0 
		: rhs[i] != '\0'
			? -1 
				: lhs[i] != '\0';
}

static DS_constexpr14 int
string_compare(char const * lhs, char const * rhs, size_t size_) noexcept
{
	size_t i = 0;
	for(; i < size_ && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return i == size_ && rhs[i] == '\0' 
		? 0
		: rhs[i] != '\0' 
			? -1 
			: i != size_;
}

static DS_constexpr14 int
string_compare(char const * lhs, char const * rhs, size_t lsize, size_t rsize) noexcept
{
	size_t i = 0;
	for(; i < lsize && i < rsize; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return i == lsize && i == rsize
		? 0
		: i == lsize
			? -1 
			: i == rsize;
}

static DS_constexpr14 int
string_partial_compare(char const * lhs, char const * rhs) noexcept
{
	size_t i = 0;
	for(; lhs[i] != '\0' && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return 0;
}

static DS_constexpr14 int
string_partial_compare(char const * lhs, char const * rhs, size_t size_) noexcept
{
	size_t i = 0;
	for(; i < size_ && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return 0;
}

static DS_constexpr14 int
string_partial_compare(char const * lhs, char const * rhs, size_t lsize, size_t rsize) noexcept
{
	return string_partial_compare(lhs, rhs, min(lsize, rsize));
}

template <typename E, size_t size_> static constexpr size_t size(E (& array_)[size_])       { return size_; }
template <typename E, size_t size_> static constexpr size_t size(E const (& array_)[size_]) { return size_; }

template <typename E, size_t size_> static constexpr E       * begin(E (& array_)[size_])       { return &array_[0]; }
template <typename E, size_t size_> static constexpr E       * end(E (& array_)[size_])         { return &array_[size_]; }
template <typename E, size_t size_> static constexpr E const * begin(E const (& array_)[size_]) { return &array_[0]; }
template <typename E, size_t size_> static constexpr E const * end(E const (& array_)[size_])   { return &array_[size_]; }

template <class C, typename sz_t = decltype(decl<C &>().size())>       static constexpr sz_t size(C & object_)           { return object_.size(); }
template <class C, typename sz_t = decltype(decl<C const &>().size())> static constexpr sz_t size(C const & object_)     { return object_.size(); }


template <class C, typename it_t = decltype(decl<C &>().begin())>       static constexpr it_t begin(C & object_)         { return object_.begin(); }
template <class C, typename it_t = decltype(decl<C &>().end())>         static constexpr it_t end(C & object_)           { return object_.end(); }
template <class C, typename it_t = decltype(decl<C const &>().begin())> static constexpr it_t begin(C const & object_)   { return object_.begin(); }
template <class C, typename it_t = decltype(decl<C const &>().end())>   static constexpr it_t end(C const & object_)     { return object_.end(); }

template <class C, typename it_t = decltype(decl<C &>().rbegin())>       static constexpr it_t rbegin(C & object_)       { return object_.rbegin(); }
template <class C, typename it_t = decltype(decl<C &>().rend())>         static constexpr it_t rend(C & object_)         { return object_.rend(); }
template <class C, typename it_t = decltype(decl<C const &>().rbegin())> static constexpr it_t rbegin(C const & object_) { return object_.rbegin(); }
template <class C, typename it_t = decltype(decl<C const &>().rend())>   static constexpr it_t rend(C const & object_)   { return object_.rend(); }

namespace traits {
	template <typename T> struct iterable;
} // namespace traits

template <class C, typename E>
struct inserter
{
	// C & container;
	// bool init(size_t required_size);
	// template <typename T>
	// bool insert(T && object);
};

namespace _ {
	template <class C, typename E
			, typename = decltype(decl<ds::inserter<C,E>>().insert(decl<E>()))
		> true_type has_inserter(int);
	template <class C, typename E> false_type has_inserter(...);
} // namespace _

template <class C, typename E> struct has_inserter : decltype(_::has_inserter<C,E>(0)) {};

template <class C, typename E = typename traits::iterable<C>::element_t>
using inserter_t = conditional_t<has_inserter<remove_reference_t<C>,E>::value
		, ds::inserter<C,E>
		, void
	>;

template <class C, typename E = typename traits::iterable<C>::element_t>
using enabled_inserter_t = enable_if_t<has_inserter<remove_reference_t<C>,E>::value
		, ds::inserter<C,E>
	>;


template <typename K, typename V>
struct Entry
{
	K const key   {};
	V       value {};

	constexpr Entry() = default;
	constexpr Entry(Entry &&) = default;
	constexpr Entry(Entry const &) = default;
	Entry & operator=(Entry &&) = default;
	Entry & operator=(Entry const &) = default;

	template <typename K_ = K, enable_if_t<is_constructible<K,K_>::value,int> = 0>
	constexpr explicit Entry(K_ && key_)
		: key   { ds::forward<K_>(key_) }
	{}

	template <typename K_ = K, typename V_ = V
			, enable_if_t<is_constructible<K,K_>::value,int> = 0
			, enable_if_t<is_constructible<V,V_>::value,int> = 0>
	constexpr Entry(K_ && key_, V_ && value_)
		: key   { ds::forward<K_>(key_) }
		, value { ds::forward<V_>(value_) }
	{}

	template <typename = decltype(decl<K>() == decl<K>())>
	constexpr bool 
	operator==(Entry const & rhs) const noexcept
	{ return key == rhs.key; }

	template <typename = decltype(decl<K>() == decl<K>())>
	constexpr bool 
	operator==(K const & key_) const noexcept
	{ return key == key_; }

	template <typename T, typename = decltype(decl<K>() == decl<T>())>
	constexpr bool 
	operator==(T && key_) const noexcept
	{ return key == key_; }

	template <typename = decltype(decl<K>() < decl<K>())>
	constexpr bool 
	operator<(Entry const & rhs) const noexcept
	{ return key < rhs.key; }

	template <typename = decltype(decl<K>() < decl<K>())>
	constexpr bool 
	operator<(K const & key_) const noexcept
	{ return key < key_; }

	template <typename T, typename = decltype(decl<K>() < decl<T>())>
	constexpr bool 
	operator<(T && key_) const noexcept
	{ return key < key_; }

};

template <typename K, typename V> using entry = Entry<K,V>;

template <typename K, typename V>
struct Hasher<Entry<K,V>>
{
	static inline size_t hash(Entry<K,V> const & s) { return Hasher<K>::hash(s.key); }
	static inline size_t hash(K const & key) { return Hasher<K>::hash(key); }
	template <typename T, typename = decltype(Hasher<K>::hash(decl<T>()))>
	static inline size_t hash(T && key) { return Hasher<K>::hash(key); }
};

template <typename K, typename V>
struct OrderedHasher<Entry<K,V>> : integral_constant<size_t,OrderedHasher<K>::value>
{
	static inline size_t hash(Entry<K,V> const & s) { return OrderedHasher<K>::hash(s.key); }
	static inline size_t hash(K const & key) { return OrderedHasher<K>::hash(key); }
	template <typename T, typename = decltype(OrderedHasher<K>::hash(decl<T>()))>
	static inline size_t hash(T && key) { return OrderedHasher<K>::hash(key); }
};

static thread_local char const * stream_separator = ", ";
static thread_local char const * stream_separator_key_value = ": ";

template <class OST, typename K, typename V
		, enable_if_t<is_out_streamable<OST,K>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,V>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,char const *>::value,int> = 0
	>
static OST & 
operator<<(OST && ost, ds::Entry<K,V> const & rhs)
{
	return ost << rhs.key << stream_separator_key_value << rhs.value;
}


template <class OST, typename C
		, typename SZ = decltype(size(decl<C const &>()))
		, typename IT = decltype(begin(decl<C const &>()))
		, typename ET = decltype(*decl<IT &>())
		, typename    = decltype(end(decl<C const &>()))
		, typename    = decltype(++decl<IT &>())
		, enable_if_t<is_out_streamable<OST,ET>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,char const *>::value,int> = 0
	>
static OST & 
operator<<(OST && ost, C const & rhs)
{
	if(size(rhs) == 0)
		return ost;
	auto end_ = end(rhs);
	for(auto it = begin(rhs);;)
	{
		ost << *it;
		if(++it != end_)
			ost << stream_separator;
		else 
			break;
	}
	return ost;
}

template <class OST, typename E, size_t size_
		, enable_if_t<is_out_streamable<OST,E>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,char const *>::value,int> = 0
	>
static OST & 
operator<<(OST && ost, E const (& rhs)[size_])
{
	if(size(rhs) == 0)
		return ost;
	auto end_ = end(rhs);
	for(auto it = begin(rhs);;)
	{
		ost << *it;
		if(++it != end_)
			ost << stream_separator;
		else 
			break;
	}
	return ost;
}

template <size_t size_, size_t align_ = alignof(max_align_t)>
struct AlignedBytes
{
	alignas(align_) byte_t bytes[size_];
	
	AlignedBytes(noinit_t) noexcept
	{}
	
	AlignedBytes() noexcept
		: bytes {}
	{}
	
	size_t      size()  const noexcept { return size_; }
	byte_ptr_t  begin()       noexcept { return &bytes[0]; }
	byte_ptr_t  end()         noexcept { return &bytes[size_]; }
	byte_cptr_t begin() const noexcept { return &bytes[0]; }
	byte_cptr_t end()   const noexcept { return &bytes[size_]; }
	
};

template <size_t size_, align_t align_ = alignof(max_align_t)>
using aligned_bytes = AlignedBytes<size_,align_>;

enum class duplicate_rule
{
	allow     = 1, // Allow duplicates.
	unique    = 2, // No duplicates but no replacing.
	replace   = 3, // Replace duplicates.
};

// returns the upper-case hexadecimal representation of 'value' 0-F
// truncates on overflow to max. i.e. F
static constexpr char
hex_char(uint8_t value) 
{
	return value <= 9 ? ('0' + value) : (value <= 15 ? ('A' + value - 10) : 'F');
}

// returns the lower-case hexadecimal representation of 'value' 0-f
// truncates on overflow to max. i.e. f
static constexpr char
hex_char_lower(uint8_t value) 
{
	return value <= 9 ? ('0' + value) : (value <= 15 ? ('a' + value - 10) : 'f');
}

// returns the base-10 value of 'hex_char' which is expected to be a hexadecimal ([0-F]|[0-f])
// returns 0 on invalid input
static constexpr uint8_t  
hex_value(char hex_char) 
{
	return (hex_char >= '0' && hex_char <= '9')
		? uint8_t(hex_char - '0')
		: (hex_char >= 'a' && hex_char <= 'f')
			? 10 + uint8_t(hex_char - 'a')
			: (hex_char >= 'A' && hex_char <= 'F')
				? 10 + uint8_t(hex_char - 'A')
				: 0;
}

// efficient reverse.
template<typename It
		, typename = decltype(ds::swap(*decl<It &>(), *decl<It &>()))
	> 
static DS_constexpr14 void
reverse(It begin_, It end_)
{
	if(begin_ == end_)
		return;
	while(begin_ != --end_)
	{
		ds::swap(*begin_, *end_);
		if(++begin_ == end_)
			break;
	}
}

// efficient reverse.
template <typename T
		, typename = decltype(begin(decl<T>()))
		, typename = decltype(end(decl<T>()))
	>
static DS_constexpr14 void
reverse(T && f_iterable)
{
	ds::reverse(ds::begin(f_iterable), ds::end(f_iterable));
}

template<typename It, class C = less<remove_cvref_t<decltype(*decl<It &>())>>
		, enable_if_t<is_same<decltype(decl<It &>() == decl<It &>()),bool>::value,int> = 0
		, enable_if_t<is_same<decltype(++decl<It &>()),It &>::value,int> = 0
		, typename = decltype(*decl<It &>())
	> 
static DS_constexpr14 bool
is_sorted(It begin_, It end_, C && compare = {}) noexcept
{
	for(auto it = begin_, next_ = begin_; ; it = next_)
	{
		if(++next_ == end_)
			break;
		if(compare(*next_, *it))
			return false;
	}
	return true;
}

template <typename T, class C = less<remove_cvref_t<decltype(*begin(decl<T &>()))>>
		, typename = decltype(ds::is_sorted(begin(decl<T const &>()), end(decl<T const &>()), decl<C>()))
	>
static DS_constexpr14 bool
is_sorted(T const & f_iterable, C && compare = {}) noexcept
{
	return ds::is_sorted(begin(f_iterable), end(f_iterable), ds::forward<C>(compare));
}

namespace _ {
	template <typename E, class C>
	static DS_constexpr14 void
	_sort2(E & a, E & b, C && compare)
	{
		if(compare(b, a))
			ds::swap(a, b);
	}

	template <typename E, class C>
	static DS_constexpr14 void
	_sort3(E & a, E & b, E & c, C && compare)
	{
		if(compare(a, b))
		{
			if(compare(c, b))
			{
				if(compare(a, c))
				{
					ds::swap(b, c);
				}
				else
				{
					ds::swap(b, c);
					ds::swap(a, b);
				}
			}
		}
		else if(compare(a, c))
		{
			ds::swap(a, b);
		}
		else if(compare(c, b))
		{
			ds::swap(a, c);
		}
		else 
		{
			ds::swap(a, c);
			ds::swap(a, b);
		}
	}

	template <typename E, class C>
	static DS_constexpr14 void
	_sort4(E & a, E & b, E & c, E & d, C && compare)
	{
		if(compare(a, b))
		{
			if(compare(a, c))
			{
				if(compare(d, a))
					ds::swap(a, d);
			}
			else if(compare(d, c))
				ds::swap(a, d);
			else
				ds::swap(a, c);
		}
		else
		{
			if(compare(b, c))
			{
				if(compare(b, d))
					ds::swap(a, b);
				else
					ds::swap(a, d);
			}
			else if(compare(d, c))
				ds::swap(a, d);
			else
				ds::swap(a, c);
		}
		_sort3(b, c, d, ds::forward<C>(compare));
	}

} // namespace _

template<typename It, class C = less<decltype(*decl<It &>())>>
static DS_constexpr14 void
selection_sort(It begin_, It end_, C && compare = {}) noexcept
{
	if(begin_ != end_)
	{
		{
			auto last_          = end_ - 1;
			auto sorted         = true;
			auto reverse_sorted = true;
			for(auto it = begin_, next_ = begin_; it < last_; it = next_)
			{
				++next_;
				if(sorted && compare(*next_, *it))
				{
					sorted = false;
					if(!reverse_sorted)
						break;
				}
				else if(reverse_sorted && compare(*it, *next_))
				{
					reverse_sorted = false;
					if(!sorted)
						break;
				}
			}
			if(sorted)
				return;
			else if(reverse_sorted)
			{
				ds::reverse(begin_, end_);
				return;
			}
		}
		{
			auto last_ = end_ - 1;
			for(auto it = begin_; it != last_; ++it)
			{
				auto cit = it;
				auto sit = it + 1;
				for(; sit != end_; ++sit)
				{
					if(compare(*sit, *cit))
						cit = sit;
				}
				if(cit != it)
					ds::swap(*cit, *it);
			}
		}
	}
}

// a very quick quick-sort.
template<typename It, class C = less<decltype(*decl<It &>())>
		, enable_if_t<is_integral<decltype(decl<It &>() - decl<It &>())>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() < decl<It &>()),bool>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() <= decl<It &>()),bool>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() - size_t(1)),It>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() + size_t(1)),It>::value,int> = 0
		, typename = decltype(ds::swap(*decl<It &>(), *decl<It &>()))
	> 
static DS_constexpr14 void 
sort(It begin_, It end_, C && compare = {}) noexcept
{
	auto size_ = size_t(end_ - begin_);
	if(size_ <= 1)
		return;
	else if(size_ == 2)
		return _::_sort2(*begin_, *(begin_ + 1), compare);
	else if(size_ == 3)
		return _::_sort3(*begin_, *(begin_ + 1), *(begin_ + 2), compare);
	else if(size_ == 4)
		return _::_sort4(*begin_, *(begin_ + 1), *(begin_ + 2), *(begin_ + 3), compare);
	else if(size_ <= 7)
		return selection_sort(begin_, end_, compare);
	else 
	{
		// check if sorted
		{
			auto last_          = end_ - 1;
			auto sorted         = true;
			auto reverse_sorted = true;
			for(auto it = begin_, next_ = begin_; it < last_; it = next_)
			{
				++next_;
				if(sorted && compare(*next_, *it))
				{
					sorted = false;
					if(!reverse_sorted)
						break;
				}
				else if(reverse_sorted && compare(*it, *next_))
				{
					reverse_sorted = false;
					if(!sorted)
						break;
				}
			}
			if(sorted)
				return;
			else if(reverse_sorted)
			{
				ds::reverse(begin_, end_);
				return;
			}
		}
		// sort
		{
			auto pivot = begin_;
			auto left  = begin_ + 1;
			auto right = end_ - 1;
			while(left < right)
			{
				while(left < right && compare(*left, *pivot))
					++left;
				while(left <= right && !compare(*right, *pivot))
					--right;
				if(left < right)
				{
					ds::swap(*left, *right);
					++left;
					--right;
				}
			}
			if(right != pivot)
			{
				if(compare(*left, *pivot))
					ds::swap(*pivot, *left);
				else
					ds::swap(*pivot, *(--left));
			}
			else
				--left;
			ds::sort(begin_, left, compare);
			ds::sort(left + 1, end_, compare);
		}
	}
}

// a very quick quick-sort.
template<typename It, class C = less<decltype(*decl<It &>())>
		, enable_if_t<is_same<decltype(decl<It &>() != decl<It &>()),bool>::value,int> = 0
		, enable_if_t<is_same<decltype(++decl<It &>()),It &>::value,int> = 0
		, enable_if_t<is_same<decltype(--decl<It &>()),It &>::value,int> = 0
		, typename = decltype(ds::swap(*decl<It &>(), *decl<It &>()))
	> 
static DS_constexpr14 void 
sortl(It begin_, It end_, size_t size_, C && compare = {}) noexcept
{
	if(size_ > 1)
	{
		if(size_ == 2)
		{
			auto & next_0 = *(begin_);
			auto & next_1 = *(++begin_);
			_::_sort2(next_0, next_1, compare);
		}
		else if(size_ == 3)
		{
			auto & next_0 = *(begin_);
			auto & next_1 = *(++begin_);
			auto & next_2 = *(++begin_);
			_::_sort3(next_0, next_1, next_2, compare);
		}
		else if(size_ == 4)
		{
			auto & next_0 = *(begin_);
			auto & next_1 = *(++begin_);
			auto & next_2 = *(++begin_);
			auto & next_3 = *(++begin_);
			_::_sort4(next_0, next_1, next_2, next_3, compare);
		}
		else 
		{
			// check if sorted
			{
				auto last_ = end_; --last_;
				bool sorted         = true;
				bool reverse_sorted = true;
				for(auto it = begin_, next_ = begin_; it != last_; it = next_)
				{
					++next_;
					if(sorted && compare(*next_, *it))
					{
						sorted = false;
						if(!reverse_sorted)
							break;
					}
					else if(reverse_sorted && compare(*it, *next_))
					{
						reverse_sorted = false;
						if(!sorted)
							break;
					}
				}
				if(sorted)
					return;
				else if(reverse_sorted)
				{
					ds::reverse(begin_, end_);
					return;
				}
			}
			// sort
			{
				auto last_  = end_;   --last_;
				auto next_  = begin_; ++next_;
				auto pivot  = begin_;
				auto left   = next_;
				auto right  = last_;
				auto lsize_ = size_t(1);
				while(left != right)
				{
					while(left != right && compare(*left, *pivot))
					{
						++left;
						++lsize_;
					}
					while(!compare(*right, *pivot))
					{
						if(left == right)
							break;
						--right;
					}
					if(left != right)
					{
						ds::swap(*left, *right);
						++left; 
						++lsize_;
						if(left != right)
							--right;
					}
				}
				if(right != pivot)
				{
					if(compare(*left, *pivot))
						ds::swap(*pivot, *left);
					else
					{
						ds::swap(*pivot, *(--left));
						--lsize_;
					}
				}
				else
				{
					--left;
					--lsize_;
				}
				size_t rsize_ = (size_ - lsize_) - 1;
				ds::sortl(begin_, left, lsize_, compare);
				ds::sortl(++left, end_, rsize_, compare);
			}
		}
	}
}

namespace _ {
	template <typename T, class C
			, typename = decltype(ds::sort(begin(decl<T>()), end(decl<T>()), decl<C>()))
		>
	static constexpr true_type _test_sort(int);
	template <typename T, class C>
	static constexpr false_type _test_sort(...);

	template <typename T, class C
			, typename = decltype(ds::sortl(begin(decl<T>()), end(decl<T>()), size(decl<T>()), decl<C>()))
		>
	static constexpr true_type _test_sortl(int);
	template <typename T, class C>
	static constexpr false_type _test_sortl(...);
} // namespace _

// a very quick quick-sort.
template <typename T, class C = less<remove_cvref_t<decltype(*begin(decl<T &>()))>>
		, enable_if_t<(decltype(_::_test_sort<T,C>(0))::value),int> = 0
	>
static DS_constexpr14 T &&
sort(T && fr_iterable, C && compare = {})
{
	ds::sort(begin(fr_iterable), end(fr_iterable), ds::forward<C>(compare));
	return ds::forward<T>(fr_iterable);
}

// a very quick quick-sort.
template <typename T, class C = less<remove_cvref_t<decltype(*begin(decl<T &>()))>>
		, enable_if_t<(!decltype(_::_test_sort<T,C>(0))::value && decltype(_::_test_sortl<T,C>(0))::value),int> = 0
	>
static DS_constexpr14 T &&
sort(T && fr_iterable, C && compare = {})
{
	ds::sortl(begin(fr_iterable), end(fr_iterable), size(fr_iterable), ds::forward<C>(compare));
	return ds::forward<T>(fr_iterable);
}

template <typename It, typename E = remove_cvref_t<decltype(*decl<It &>())>
		, typename C = less<E>
		, typename = decltype(*decl<It &>())
		, typename = decltype(++decl<It &>())
		, typename = decltype(decl<It &>() + decl<size_t>())
		, typename = decltype(ds::swap(*decl<It &>(), *decl<It &>()))
		, typename = decltype(decl<C>()(decl<E const &>(), decl<E const &>()))
	>
static DS_constexpr14 void
heapify(It begin_, It end_, C && compare = {})
{
	if(begin_ != end_)
	{
		size_t j = 0;
		for(auto it = begin_; it != end_; ++it, ++j)
		{
			for(size_t i = j; i > 0;)
			{
				size_t p = (i - 1) / 2;
				auto & parent = *(begin_ + p);
				auto & child  = *(begin_ + i);
				if(compare(child, parent))
					ds::swap(child, parent);
				i = p;
			}
		}
	}
}

template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(begin(decl<T const &>()))
		, typename UB = decltype(begin(decl<U const &>()))
		, typename    = decltype(end(decl<T const &>()))
		, typename    = decltype(end(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(++decl<TB &>())
		, typename    = decltype(++decl<UB &>())
	>
static DS_constexpr14 bool
begins_with(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lit = begin(lhs);
	auto ren = end(rhs);
	for(auto rit = begin(rhs); rit != ren; ++rit, ++lit)
		if(*rit != *lit)
			return false;
	return true;
}

template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(rbegin(decl<T const &>()))
		, typename UB = decltype(rbegin(decl<U const &>()))
		, typename    = decltype(rend(decl<T const &>()))
		, typename    = decltype(rend(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(--decl<TB &>())
		, typename    = decltype(--decl<UB &>())
	>
static DS_constexpr14 bool
ends_with(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lit = rbegin(lhs);
	auto ren = rend(rhs);
	for(auto rit = rbegin(rhs); rit != ren; --rit, --lit)
		if(*rit != *lit)
			return false;
	return true;
}

template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(begin(decl<T const &>()))
		, typename UB = decltype(begin(decl<U const &>()))
		, typename    = decltype(end(decl<T const &>()))
		, typename    = decltype(end(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(++decl<TB &>())
		, typename    = decltype(++decl<UB &>())
	>
static DS_constexpr14 bool
contians(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lend = end(lhs);
	auto rend = end(rhs);
	for(auto lit = begin(lhs); lit != lend; ++lit)
	{
		bool match_ = true;
		auto lit2 = lit;
		for(auto rit = begin(rhs); rit != rend; ++rit, ++lit2) 
			if(*lit2 != *rit)
				match_ = false;
		if(match_)
			return true;
	}
	return false;
}

template <size_t lsize_, size_t rsize_>
static DS_constexpr14 bool
contians(char const (& lhs)[lsize_], char const (& rhs)[rsize_]) noexcept
{
	size_t lsize = lsize_ - 1;
	size_t rsize = rsize_ - 1;
	if(lsize < rsize)
		return false;
	auto lend = &lhs[lsize];
	auto rend = &rhs[rsize];
	for(auto lit = &lhs[0]; lit != lend; ++lit)
	{
		bool match_ = true;
		auto lit2 = lit;
		for(auto rit = &rhs[0]; rit != rend; ++rit, ++lit2) 
			if(*lit2 != *rit)
				match_ = false;
		if(match_)
			return true;
	}
	return false;
}

template <typename E, class It, class Ite
		, typename    = decltype(*decl<It &>())
		, typename    = decltype(++decl<It &>())
		, typename    = decltype(*decl<It &>() == decl<E &>())
		, typename    = decltype(decl<It &>() != decl<Ite &>())
	>
static DS_constexpr14 size_t 
find(E && object, It && begin_it, Ite && end_, size_t skip_ = 0)
{
	size_t i = 0;
	for(; begin_it != end_; ++begin_it)
	{
		if(*begin_it == object && skip_-- == 0)
			return i;
		++i;
	}
	return -1;
}

template <typename E, class C>
static DS_constexpr14 size_t 
find(E && object, C && in_iterable, size_t skip_ = 0)
{
	size_t i = 0;
	for(auto const & e : in_iterable)
	{
		if(e == object && skip_-- == 0)
			return i;
		++i;
	}
	return -1;
}

template <typename E, class C
		, typename It = decltype(begin(decl<C &>()))
	>
static DS_constexpr14 It
binary_search(E && object, C && iterable, size_t skip_ = 0)
{
	auto _size  = size(iterable);
	if(_size == 0)
		return {};
	else if(_size < 3)
	{
		auto it = begin(iterable);
		if(ds::find(object, it, end(iterable), skip_) == size_t(-1))
			return {};
		return it;
	}
	else
	{
		auto _left  = begin(iterable);
		auto _right = end(iterable); --_right;
		auto _mid   = _left + _size / 2;
		auto _left_most_of = [](It it_, It begin_)
		{
			auto const & _object = *it_;
			for(auto it = it_; ; --it)
			{
				if(*it != _object)
					return ++it;
				if(it == begin_)
					return it;
			}
		};
		auto _skip = [&](It it_, size_t skip_)
		{
			auto const & _object = *it_;
			bool _equal = false;
			while((_equal = (*it_ == _object)) && skip_-- > 0)
				++it_;
			return _equal ? it_ : It{};
		};
		while(_size > 0)
		{
			if(*_left == object)
				return _skip(_left, skip_);
			else if(*_mid == object)
				return _skip(_left_most_of(_mid, _left), skip_);
			else if(*_right == object)
				return _skip(_left_most_of(_right, _left), skip_);
			else if(object < *_mid)
			{
				++_left;
				_right = --_mid;
				_size = size_t(_right - _left);
			}
			else
			{
				--_right;
				_left = ++_mid;
				_size = size_t(_right - _left);
			}
			_mid = _left + _size / 2;
		}
	}
	return {};
}

template <typename E, class It, class Ite
		, typename    = decltype(*decl<It &>())
		, typename    = decltype(++decl<It &>())
		, typename    = decltype(*decl<It &>() == decl<E &>())
		, typename    = decltype(decl<It &>() != decl<Ite &>())
	>
static DS_constexpr14 size_t 
count(E && object, It && begin_, Ite && end_, size_t skip_ = 0)
{
	size_t _count = 0;
	for(auto it = begin_; it != end_; ++it)
	{
		if(*it == object)
		{
			if(skip_ == 0)
				++_count;
			else
				--skip_;
		}
	}
	return _count;
}

template <typename E, class C
		, typename It  = decltype(begin(decl<C &>()))
		, typename Ite = decltype(end(decl<C &>()))
		, typename    = decltype(++decl<It &>())
		, typename    = decltype(*decl<It &>() == decl<E &>())
		, typename    = decltype(decl<It &>() != decl<Ite &>())
	>
static DS_constexpr14 size_t 
count(E && object, C && in_iterable, size_t skip_ = 0)
{
	size_t _count = 0;
	for(auto const & e : in_iterable)
	{
		if(e == object)
		{
			if(skip_ == 0)
				++_count;
			else
				--skip_;
		}
	}
	return _count;
}

template <typename T>
static constexpr T
factorial(T n)
{
	return n <= 1 ? 1 : n * factorial(n - 1);
} 

template <typename E
		, typename = decltype(decl<E>() + decl<size_t>())
		, typename = decltype(*decl<E>())
		, typename = decltype(decl<E>() - decl<E>())
		, typename = decltype(ds::swap(*decl<E>(), *decl<E>()))
	>
static DS_constexpr14 void
permutate(uint64_t seq_n_, E begin_, E end_)
{
	size_t size_ = size_t(end_ - begin_);
	if(size_ <= 1)
		return;
	uint64_t N          = factorial<uint64_t>(size_ - 1);
	size_t   i          = size_t(seq_n_ / N);
	size_t   next_perm_ = size_t(seq_n_ % N);
	if(i > 0 && i < size_)
	{
		for(auto it = begin_ + i; it != begin_;)
		{
			auto cit = it--;
			ds::swap(*it, *cit);
		}
	}
	if(next_perm_ > 0)
		permutate(next_perm_, begin_ + 1, end_);
}

template <class C
		, typename Begin = decltype(begin(decl<C>()))
		, typename End   = decltype(end(decl<C>()))
		, typename       = decltype(decl<End &>() - decl<Begin &>())
	>
static DS_constexpr14 C &&
permutate(uint64_t seq_n_, C && iterable)
{
	permutate(seq_n_, ds::begin(iterable), ds::end(iterable));
	return ds::forward<C>(iterable);
}

template <class C
		, typename = decltype(permutate(decl<uint64_t>(), decl<C>()))
	>
static DS_constexpr14 C
permutated(uint64_t seq_n_, C const & iterable)
{
	C _permutated(iterable);
	permutate(seq_n_, _permutated);
	return ds::move(_permutated);
}

template <class C>
static DS_constexpr14 uint64_t
permutation_seq_n(C const & permutated_)
{
	auto size_ = ds::size(permutated_);
	if(size_ <= 1)
		return 0;
	auto _sorted = permutated_;
	ds::sort(_sorted);
	uint64_t _seq_n = 0;
	auto size_1 = size_ - 1;
	for(size_t i = 0; i < size_1; ++i)
	{
		auto _n_      = factorial<uint64_t>(size_ - i - 1);
		auto _count   = count(permutated_[i], &_sorted[0], &_sorted[i]);
		auto sorted_i = find(permutated_[i], _sorted, _count);
		if(i != sorted_i) 
		{
			for(auto it = &_sorted[sorted_i]; it != &_sorted[i];)
			{
				auto cit = it--;
				ds::swap(*it, *cit);
			}
		}
		_seq_n += (sorted_i - i) * _n_;
	}
	return _seq_n;
}


template <typename T = float, class C>
static DS_constexpr14 T
mean(C && iterable)
{
	auto _count = size(iterable);
	if(_count == 0)
		return 0;
	auto _begin = begin(iterable);
	auto _end   = end(iterable);
	auto _mean  = *(_begin++);
	for(; _begin != _end; ++_begin)
		_mean += *_begin;
	return _mean / _count;
}


template <typename T = float, class C>
static DS_constexpr14 T
variance(C && iterable)
{
	auto _count = size(iterable);
	if(_count < 2)
		return 0;
	auto _begin    = begin(iterable);
	auto _end      = end(iterable);
	auto _mean     = mean<T>(iterable);
	auto _variance = T(0);
	for(; _begin != _end; ++_begin)
	{
		auto _val   = T(*_begin);
		auto _delta = abs(_val - _mean);
		_variance += _delta * _delta;
	}
	_variance /= (_count - 1);
	return _variance;
}


template <typename T = float, class C>
static DS_constexpr14 T
standard_deviation(C && iterable)
{
	return std::sqrt(variance<T>(ds::forward<C>(iterable)));
}


template <class C, class P
		, typename It = decltype(begin(decl<C>()))
	>
static DS_constexpr14 It
find_best(C && iterable, P && test_)
{
	auto _size  = size(iterable);
	if(_size == 0)
		return {};
	auto _begin = begin(iterable);
	auto _end   = end(iterable);
	auto _candidate = It{};
	for(; _begin != _end; ++_begin)
	{
		if(!_candidate)
		{
			if(test_(*_begin, *_begin))
				_candidate = _begin;
		}
		else if(test_(*_begin, *_candidate))
			_candidate = _begin;
	}
	return _candidate;
}

template <class C, class P = less<remove_cvref_t<decltype(*begin(decl<C>()))>>
		, typename It = decltype(begin(decl<C>()))
	>
static DS_constexpr14 It
find_min(C && iterable, P && compare = {})
{
	auto _size  = size(iterable);
	if(_size == 0)
		return {};
	auto _begin = begin(iterable);
	auto _end   = end(iterable);
	auto _candidate = _begin;
	for(++_begin; _begin != _end; ++_begin)
	{
		if(compare(*_begin, *_candidate))
			_candidate = _begin;
	}
	return _candidate;
}

template <class C, class P = greater<remove_cvref_t<decltype(*begin(decl<C>()))>>
		, typename It = decltype(begin(decl<C>()))
	>
static DS_constexpr14 It
find_max(C && iterable, P && compare = {})
{
	auto _size  = size(iterable);
	if(_size == 0)
		return {};
	auto _begin = begin(iterable);
	auto _end   = end(iterable);
	auto _candidate = _begin;
	for(++_begin; _begin != _end; ++_begin)
	{
		if(compare(*_begin, *_candidate))
			_candidate = _begin;
	}
	return _candidate;
}


} // namespace ds

#endif // DS_COMMON
