#pragma once
#ifndef DS_COMMON
#define DS_COMMON

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <cstdio>
#include <cassert>
#include <exception>
#include <new>
#include "macros"

#ifdef min
#	undef min
#endif
#ifdef max
#	undef max
#endif

namespace ds {

static constexpr struct Version { int major, minor, patch; } version { 0, 23, 97 };

using std::exception;
using std::bad_alloc;
using std::nothrow_t;
using std::nothrow;
using std::nullptr_t;
using byte_t       = unsigned char;
using align_t      = size_t;
using byte_ptr_t   = byte_t *;
using byte_cptr_t  = byte_t const *;
using max_align_t  = std::max_align_t;
#if DS_Cxx_Version < DS_Cxx_Version_20
using char8_t = unsigned char;
#endif

template <size_t size_, typename T> using fixed_ref_t  = T (&)[size_];
template <size_t size_, typename T> using fixed_cref_t = T const (&)[size_];
template <size_t size_, typename T> using fixed_ptr_t  = T (*)[size_];
template <size_t size_, typename T> using fixed_cptr_t = T const (*)[size_];

template <typename E> using array_ref_t  = E (&)[];
template <typename E> using array_cref_t = E const (&)[];
template <typename E> using array_ptr_t  = E (*)[];
template <typename E> using array_cptr_t = E const (*)[];

struct noinit_t {};

template <typename T>
struct inplace {};

template <typename T>
struct make {};

static constexpr noinit_t noinit {};
static constexpr double   nanf   = float(__builtin_nan("0"));
static constexpr double   nan    = double(__builtin_nan("0"));
#if defined(__GNUC__)
static constexpr double   inff   = float(__builtin_inf());
static constexpr double   inf    = double(__builtin_inf());
#else
static constexpr double   inff   = float(1e300 * 1e300);
static constexpr double   inf    = double(1e300 * 1e300);
#endif

namespace _ {
	static constexpr uint32_t _endian_test_u32  = uint32_t(0x01020304);
	static constexpr uint8_t  _endian_test_byte = static_cast<uint8_t const &>(_endian_test_u32);
} // namespace _

static constexpr bool big_endian    = _::_endian_test_byte == 0x01;
static constexpr bool little_endian = _::_endian_test_byte == 0x04;
static constexpr bool middle_endian = _::_endian_test_byte == 0x02;
static_assert(big_endian || little_endian || middle_endian,  "unknown endian");

namespace _ {
	template <typename T, size_t = sizeof(T)>
	struct _to_bige
	{};

	template <typename T>
	struct _to_bige<T,1>
	{
		static constexpr T
		convert(T value)
		{
			return value;
		}
	};

	template <typename T>
	struct _to_bige<T,2>
	{
		static constexpr T
		convert(T value)
		{
			return big_endian
				? value
				: (
					  ((value & 0x00FF) << 8)
					| ((value & 0xFF00) >> 8)
				  );
		}
	};

	template <typename T>
	struct _to_bige<T,4>
	{
		static constexpr T
		convert(T value)
		{
			return big_endian 
				? value
				: little_endian 
					? (
						  ((value & 0x000000FF) << 24)
						| ((value & 0x0000FF00) << 8)
						| ((value & 0x00FF0000) >> 8)
						| ((value & 0xFF000000) >> 24)
					  )
					: (
						  ((value & 0x00FF0000) << 8)
						| ((value & 0xFF000000) >> 8)
						| ((value & 0x000000FF) << 8)
						| ((value & 0x0000FF00) >> 8)
					  );
		}
	};

	template <typename T>
	struct _to_bige<T,8>
	{
		static constexpr T
		convert(T value)
		{
			return big_endian 
				? value
				: little_endian 
					? (
						  ((value & 0x00000000000000FF) << 56)
						| ((value & 0x000000000000FF00) << 40)
						| ((value & 0x0000000000FF0000) << 24)
						| ((value & 0x00000000FF000000) << 8)
						| ((value & 0x000000FF00000000) >> 8)
						| ((value & 0x0000FF0000000000) >> 24)
						| ((value & 0x00FF000000000000) >> 40)
						| ((value & 0xFF00000000000000) >> 56)
					  )
					: (
						  ((value & 0x00FF000000000000) << 8)
						| ((value & 0xFF00000000000000) >> 8)
						| ((value & 0x000000FF00000000) << 8)
						| ((value & 0x0000FF0000000000) >> 8)
						| ((value & 0x0000000000FF0000) << 8)
						| ((value & 0x00000000FF000000) >> 8)
						| ((value & 0x00000000000000FF) << 8)
						| ((value & 0x000000000000FF00) >> 8)
					  );
		}
	};
} // namespace _

template <typename T>
static constexpr T
to_big_endian(T value)
{
	return _::_to_bige<T>::convert(value);
}

template <typename T>
static constexpr T
to_native_endian(T value)
{
	return _::_to_bige<T>::convert(value);
}

template <typename T> static constexpr T decl();

template <typename T>
struct type_identity
{
	using type = T;
};

template <typename T, T value_>
struct integral_constant
{
	static constexpr T value = value_;
	constexpr integral_constant() = default;
	constexpr T operator()() const noexcept { return value; };
	constexpr operator T() const noexcept { return value; };
};

template <bool value_>
using bool_constant = integral_constant<bool,value_>;

using false_type = bool_constant<false>;
using true_type  = bool_constant<true>;

template <typename T> struct add_pointer       : type_identity<T *> {};
template <typename T> struct add_pointer<T &>  : type_identity<T *> {};
template <typename T> struct add_pointer<T &&> : type_identity<T *> {};
template <typename T> using  add_pointer_t = typename add_pointer<T>::type;

template <typename T> struct add_lvalue_reference       : type_identity<T &> {};
template <typename T> struct add_lvalue_reference<T &>  : type_identity<T &> {};
template <typename T> struct add_lvalue_reference<T &&> : type_identity<T &> {};
template <typename T> using  add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template <typename T> struct add_rvalue_reference       : type_identity<T &&> {};
template <typename T> struct add_rvalue_reference<T &>  : type_identity<T &&> {};
template <typename T> struct add_rvalue_reference<T &&> : type_identity<T &&> {};
template <typename T> using  add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

template <typename T> struct remove_cv                   : type_identity<T> {};
template <typename T> struct remove_cv<T const>          : type_identity<T> {};
template <typename T> struct remove_cv<T volatile>       : type_identity<T> {};
template <typename T> struct remove_cv<T const volatile> : type_identity<T> {};
template <typename T> using  remove_cv_t = typename remove_cv<T>::type;

template <typename T> struct remove_reference       : type_identity<T> {};
template <typename T> struct remove_reference<T &>  : type_identity<T> {};
template <typename T> struct remove_reference<T &&> : type_identity<T> {};
template <typename T> using  remove_reference_t = typename remove_reference<T>::type;

template <typename T> using  remove_cvref_t     = remove_cv_t<remove_reference_t<T>>;

template <typename T> struct remove_pointer                     : type_identity<T> {};
template <typename T> struct remove_pointer<T *>                : type_identity<T> {};
template <typename T> struct remove_pointer<T * const>          : type_identity<T> {};
template <typename T> struct remove_pointer<T * volatile>       : type_identity<T> {};
template <typename T> struct remove_pointer<T * const volatile> : type_identity<T> {};
template <typename T> using  remove_pointer_t = typename remove_pointer<T>::type;

template <typename T> struct remove_pointer_cv : type_identity<add_pointer_t<remove_cv_t<remove_pointer_t<T>>>> {};
template <typename T> using  remove_pointer_cv_t = typename remove_pointer_cv<T>::type;

template <typename T> struct base_type : type_identity<remove_cv_t<remove_pointer_t<remove_cvref_t<T>>>> {}; 
template <typename T> using  base_type_t = typename base_type<T>::type;

namespace _ {
	template <typename From, typename To> struct _copy_reference             : type_identity<To> {};
	template <typename From, typename To> struct _copy_reference<From &,To>  : type_identity<To &> {};
	template <typename From, typename To> struct _copy_reference<From &&,To> : type_identity<To &&> {};
} // namespace _

template <typename From, typename To> struct copy_reference : _::_copy_reference<From,remove_reference_t<To>> {};
template <typename From, typename To> using  copy_reference_t = typename copy_reference<From,To>::type;
template <typename From, typename To> using  copy_ref_t       = typename copy_reference<From,To>::type;

namespace _ {
	template <typename From, typename To> struct _copy_cv                         : type_identity<To> {};
	template <typename From, typename To> struct _copy_cv<From const,To>          : type_identity<To const> {};
	template <typename From, typename To> struct _copy_cv<From volatile,To>       : type_identity<To volatile> {};
	template <typename From, typename To> struct _copy_cv<From const volatile,To> : type_identity<To const volatile> {};
} // namespace _

template <typename From, typename To> struct copy_cv : type_identity<
		copy_reference_t<To,typename _::_copy_cv<remove_reference_t<From>,remove_reference_t<To>>::type>
	> 
{};
template <typename From, typename To> using  copy_cv_t = typename copy_cv<From,To>::type;

template <bool condition_, typename T> struct enable_if {};
template <typename T>                  struct enable_if<true,T> : type_identity<T> {};
template <bool condition_, typename T> using  enable_if_t = typename enable_if<condition_,T>::type;

template <bool condition_, typename T, typename F> struct conditional           : type_identity<F> {};
template <typename T, typename F>                  struct conditional<true,T,F> : type_identity<T> {};
template <bool condition_, typename T, typename F> using  conditional_t = typename conditional<condition_,T,F>::type;

template <typename... Ts> struct are_all_true : false_type {};

namespace _ {
	template <typename T, bool = T::value, typename... Ts> struct _are_all_true                : false_type {};
	template <typename T>                                  struct _are_all_true<T,true>        : bool_constant<T::value> {};
	template <typename T, typename... Ts>                  struct _are_all_true<T,true,Ts...>  : bool_constant<are_all_true<Ts...>::value> {};
	template <typename T, typename... Ts>                  struct _are_all_true<T,false,Ts...> : false_type {};
} // namespace _

template <typename T, typename... Ts> struct are_all_true<T,Ts...> : bool_constant<_::_are_all_true<T,T::value,Ts...>::value> {};

template <typename... Ts> struct are_all_false : false_type {};

namespace _ {
	template <typename T, bool = T::value, typename... Ts> struct _are_all_false                : false_type {};
	template <typename T>                                  struct _are_all_false<T,false>       : bool_constant<!T::value> {};
	template <typename T, typename... Ts>                  struct _are_all_false<T,false,Ts...> : bool_constant<are_all_false<Ts...>::value> {};
	template <typename T, typename... Ts>                  struct _are_all_false<T,true,Ts...>  : false_type {};
} // namespace _

template <typename T, typename... Ts> struct are_all_false<T,Ts...> : bool_constant<_::_are_all_false<T,T::value,Ts...>::value> {};

template <typename T, typename U> struct is_same      : false_type {};
template <typename T>             struct is_same<T,T> : true_type {};

template <typename T, typename... Ts>             struct is_type_in_pack            : false_type {};
template <typename T>                             struct is_type_in_pack<T>         : false_type {};
template <typename T, typename U, typename... Ts> struct is_type_in_pack<T,U,Ts...> : bool_constant<is_type_in_pack<T,Ts...>::value> {};
template <typename T, typename... Ts>             struct is_type_in_pack<T,T,Ts...> : true_type {};

template <typename T> struct is_const             : false_type {};
template <typename T> struct is_const<T const>    : true_type {};
template <typename T> struct is_const<T const &>  : true_type {};
template <typename T> struct is_const<T const &&> : true_type {};

template <typename T> struct is_reference       : false_type {};
template <typename T> struct is_reference<T &>  : true_type {};
template <typename T> struct is_reference<T &&> : true_type {};

namespace _ {
	template <typename T> struct _is_pointer      : false_type {};
	template <typename T> struct _is_pointer<T *> : true_type {};
} // namespace _

template <typename T> struct is_pointer : _::_is_pointer<remove_cv_t<T>> {};

template <typename T>               struct is_array           : false_type {};
template <typename T>               struct is_array<T[]>      : true_type {};
template <typename T, size_t size_> struct is_array<T[size_]> : true_type {};

template <typename T>
struct is_integral : bool_constant<
		is_type_in_pack<remove_cv_t<T>
			, bool
			, char, char8_t, char16_t, char32_t, wchar_t
			, signed char, unsigned char
			, signed short, unsigned short
			, signed int, unsigned int
			, signed long, unsigned long
			, signed long long, unsigned long long
		>::value
	>
{};

template <typename T>
struct is_floating_point : bool_constant<
		is_type_in_pack<remove_cv_t<T>
			, float
			, double
			, long double
		>::value
	>
{};

template <typename T> struct is_arithmetic : bool_constant<is_integral<T>::value || is_floating_point<T>::value> {}; 

template <typename T> struct is_enum       : bool_constant<__is_enum(T)>  {};

template <typename T>
struct is_scalar : bool_constant<
		   is_arithmetic<T>::value 
		|| is_enum<T>::value 
		|| is_pointer<T>::value 
		|| is_same<remove_cv_t<T>,nullptr_t>::value
	> 
{};

template <typename T> struct is_union      : bool_constant<__is_union(T)> {};

namespace _ {
	template <typename T> bool_constant<!is_union<T>::value> _class_test(int T::*);
	template <typename T> false_type                         _class_test(...);
} // namespace _

template <typename T> struct is_class    : decltype(_::_class_test<T>(nullptr)) {};

template <typename T> struct is_function : bool_constant<!is_class<T>::value && !is_const<T const>::value && !is_reference<T>::value> {};

template <typename T>          struct is_member_pointer         : false_type {};
template <typename T, class C> struct is_member_pointer<T C::*> : true_type {};

template <typename T>          struct is_member_object_pointer         : false_type {};
template <typename T, class C> struct is_member_object_pointer<T C::*> : bool_constant<!is_function<T>::value> {};

template <typename T>          struct is_member_function_pointer         : false_type {};
template <typename T, class C> struct is_member_function_pointer<T C::*> : bool_constant<is_function<T>::value> {};

namespace _ {
	template <typename T, typename... Args
			, typename = decltype(T{decl<Args>()...})
		> true_type  _test_aggregate_initializable(int);

	template <typename T, typename... Args> false_type _test_aggregate_initializable(...);
} // namespace _

template <typename T, typename... Args>
struct is_aggregate_initializable : decltype(_::_test_aggregate_initializable<T,Args...>(0)) {};

namespace _ {
	template <typename T
			, typename = decltype(decl<T &>().~T())
		> true_type  _test_destructible(int); 

	template <typename T> false_type _test_destructible(...); 
} // namespace _

template <typename T> struct is_destructible           : decltype(_::_test_destructible<T>(0)) {};

#if defined(__GNUC__) && !defined(__clang__)
template <typename T> struct is_trivially_destructible : bool_constant<is_destructible<T>::value && __has_trivial_destructor(T)> {};
#else
template <typename T> struct is_trivially_destructible : bool_constant<__is_trivially_destructible(T)> {};
#endif

template <typename T> struct is_virtually_destructible : bool_constant<is_destructible<T>::value && __has_virtual_destructor(T)> {};

namespace _ {
	template <typename From, typename To
			, typename = decltype(static_cast<To>(decl<From>()))
		> true_type _test_static_castable(int);

	template <typename From, typename To> false_type _test_static_castable(...);

	template <typename From, typename To
			, typename = decltype(dynamic_cast<To>(decl<From>()))
		> true_type _test_dynamic_castable(int);

	template <typename From, typename To>  false_type _test_dynamic_castable(...);

	template <typename T, typename... Args
			, typename = decltype(T(decl<Args>()...))
		> true_type _test_constructible(int);

	template <typename T, typename... Args> false_type _test_constructible(...);

	template <typename T, typename U
			, typename = decltype(decl<T &>() = decl<U>())
		> true_type _test_assignable(int);
	
	template <typename T, typename U> false_type _test_assignable(...);
}


template <typename From, typename To>   struct is_static_castable         : decltype(_::_test_static_castable<From,To>(0)) {};
template <typename From, typename To>   struct is_dynamic_castable        : decltype(_::_test_dynamic_castable<From,To>(0)) {};
template <typename T, typename... Args> struct is_constructible           : decltype(_::_test_constructible<T,Args...>(0)) {};
template <typename T, typename... Args> struct is_trivially_constructible : bool_constant<__is_trivially_constructible(T,Args...)> {};
template <typename T, typename U>       struct is_assignable              : decltype(_::_test_assignable<T,U>(0)) {};
template <typename T, typename U>       struct is_trivially_assignable    : bool_constant<__is_trivially_assignable(T,U)> {};

template <typename T> using is_copy_constructible           = is_constructible<T,remove_cvref_t<T> const &>;
template <typename T> using is_trivially_copy_constructible = is_trivially_constructible<T,remove_cvref_t<T> const &>;
template <typename T> using is_move_constructible           = is_constructible<T,remove_cvref_t<T> &&>;
template <typename T> using is_trivially_move_constructible = is_trivially_constructible<T,remove_cvref_t<T> &&>;
template <typename T> using is_copy_assignable              = is_assignable<T,remove_cvref_t<T> const &>;
template <typename T> using is_move_assignable              = is_assignable<T,remove_cvref_t<T> &&>;
template <typename T> using is_trivially_copy_assignable    = is_trivially_assignable<T,remove_cvref_t<T> const &>;
template <typename T> using is_trivially_move_assignable    = is_trivially_assignable<T,remove_cvref_t<T> &&>;

template <typename T> 
struct is_signed : bool_constant<bool(T(-1) < T(0))> {};

template <typename T> 
struct is_unsigned : bool_constant<bool(T(-1) > T(0))> {};

namespace _ {
	template <typename T>   struct _is_string                                 : false_type {};
	template <>             struct _is_string<char[]>                         : true_type {};
	template <size_t size_> struct _is_string<char[size_]>                    : true_type {};
	template <>             struct _is_string<char *>                         : true_type {};
	template <>             struct _is_string<char(*)[]>                      : true_type {};
	template <size_t size_> struct _is_string<char(*)[size_]>                 : true_type {};
} // namespace _

template <typename T>   struct is_string : _::_is_string<
		conditional_t<is_pointer<T>::value
			, remove_pointer_cv_t<T>
			, remove_cvref_t<T>
		>
	> 
{};

namespace _ {
	template <class OST, typename T
			, typename = decltype(decl<OST &>() >> decl<T const &>())
		> true_type is_in_streamable(int);
	template <class OST, typename T> false_type is_in_streamable(...);

	template <class OST, typename T
			, typename = decltype(decl<OST &>() << decl<T const &>())
		> true_type is_out_streamable(int);
	template <class OST, typename T> false_type is_out_streamable(...);
} // namespace _

template <class OST, typename T> struct is_in_streamable  : decltype(_::is_in_streamable<OST,T>(0)) {};
template <class OST, typename T> struct is_out_streamable : decltype(_::is_out_streamable<OST,T>(0)) {};


template <typename T, typename U>
static constexpr T 
min(T const & lhs, U rhs) noexcept
{
	return lhs < rhs ? lhs : rhs;
}

template <typename T, typename U>
static constexpr T 
max(T const & lhs, U rhs) noexcept
{
	return lhs > rhs ? lhs : rhs;
}

template <typename T>
static constexpr T 
abs(T const & rhs) noexcept
{
	return rhs < 0 ? -rhs : rhs;
}

template <typename T>
static constexpr bool 
is_prime(T value) noexcept
{
	T N = value;
	for(T i = 2; i <= N; ++i, N /= i)
		if(value % i == 0)
			return false;
	return true;
}

template <typename T>
static constexpr T 
next_prime(T value) noexcept
{
	while(!is_prime(++value));
	return value;
}

template <typename T, size_t size_>
static fixed_cref_t<size_,T>
gen_prime_squares() noexcept
{
	static size_t prime_squares[size_];
	size_t prime_ = 1;
	for(auto & e : prime_squares)
	{
		prime_ = next_prime<size_t>(prime_);
		e = prime_ * prime_;
	}
	return prime_squares;
}

template <typename T, size_t size_>
static fixed_cref_t<size_,T>
init_prime_squares() noexcept
{
	static auto & prime_squares = gen_prime_squares<T,size_>();
	return prime_squares;
}

template <typename T>                               struct usage    { static constexpr size_t value = 0; };
template <typename T, size_t count_>                struct usage_n  { static constexpr size_t value = 0; };
template <typename T, size_t size_>                 struct usage_s  { static constexpr size_t value = 0; };
template <typename T, size_t size_, size_t count_>  struct usage_sn { static constexpr size_t value = 0; };

template <typename T, bool is_signed = bool(T(-1) < T(0)), size_t = sizeof(T)> 
struct max_integral 
{};
template <typename T> struct max_integral<T,true,1>  : integral_constant<T,T(0x7F)> {};
template <typename T> struct max_integral<T,true,2>  : integral_constant<T,T(0x7FFF)> {};
template <typename T> struct max_integral<T,true,4>  : integral_constant<T,T(0x7FFFFFFF)> {};
template <typename T> struct max_integral<T,true,8>  : integral_constant<T,T(0x7FFFFFFFFFFFFFFF)> {};
template <typename T> struct max_integral<T,false,1> : integral_constant<T,T(0xFF)> {};
template <typename T> struct max_integral<T,false,2> : integral_constant<T,T(0xFFFF)> {};
template <typename T> struct max_integral<T,false,4> : integral_constant<T,T(0xFFFFFFFF)> {};
template <typename T> struct max_integral<T,false,8> : integral_constant<T,T(0xFFFFFFFFFFFFFFFF)> {};

template <typename T, bool is_signed = bool(T(-1) < T(0)), size_t = sizeof(T)> 
struct min_integral 
{};
template <typename T> struct min_integral<T,true,1>  : integral_constant<T,T(0x80)> {};
template <typename T> struct min_integral<T,true,2>  : integral_constant<T,T(0x8000)> {};
template <typename T> struct min_integral<T,true,4>  : integral_constant<T,T(0x80000000)> {};
template <typename T> struct min_integral<T,true,8>  : integral_constant<T,T(0x8000000000000000)> {};
template <typename T> struct min_integral<T,false,1> : integral_constant<T,T(0x0)> {};
template <typename T> struct min_integral<T,false,2> : integral_constant<T,T(0x0)> {};
template <typename T> struct min_integral<T,false,4> : integral_constant<T,T(0x0)> {};
template <typename T> struct min_integral<T,false,8> : integral_constant<T,T(0x0)> {};

template <typename T> 
struct max_floating_point 
{};
template <> struct max_floating_point<float>       { static constexpr float       value = 3.402823466e+38F; };
template <> struct max_floating_point<double>      { static constexpr double      value = 1.7976931348623158e+308; };
template <> struct max_floating_point<long double> { static constexpr long double value = 1.7976931348623158e+308L; };
constexpr float       max_floating_point<float>::value;
constexpr double      max_floating_point<double>::value;
constexpr long double max_floating_point<long double>::value;

template <typename T> 
struct min_floating_point 
{};
template <> struct min_floating_point<float>       { static constexpr float       value =-3.402823466e+38F; };
template <> struct min_floating_point<double>      { static constexpr double      value =-1.7976931348623158e+308; };
template <> struct min_floating_point<long double> { static constexpr long double value =-1.7976931348623158e+308L; };
constexpr float       min_floating_point<float>::value;
constexpr double      min_floating_point<double>::value;
constexpr long double min_floating_point<long double>::value;

template <typename T, int = (is_integral<T>::value ? 1 : (is_floating_point<T>::value ? 2 : 0))>
struct max_limit 
{};
template <typename T> struct max_limit<T,1> : max_integral<T> {};
template <typename T> struct max_limit<T,2> : max_floating_point<T> {};

template <typename T, int = (is_integral<T>::value ? 1 : (is_floating_point<T>::value ? 2 : 0))>
struct min_limit 
{};
template <typename T> struct min_limit<T,1> : min_integral<T> {};
template <typename T> struct min_limit<T,2> : min_floating_point<T> {};


template <typename T>
struct integral_index 
{};
template <> struct integral_index<int8_t>   : integral_constant<size_t,0> {};
template <> struct integral_index<uint8_t>  : integral_constant<size_t,1> {};
template <> struct integral_index<int16_t>  : integral_constant<size_t,2> {};
template <> struct integral_index<uint16_t> : integral_constant<size_t,3> {};
template <> struct integral_index<int32_t>  : integral_constant<size_t,4> {};
template <> struct integral_index<uint32_t> : integral_constant<size_t,5> {};
template <> struct integral_index<int64_t>  : integral_constant<size_t,6> {};
template <> struct integral_index<uint64_t> : integral_constant<size_t,7> {};

template <typename T>
struct floating_point_index 
{};
template <> struct floating_point_index<float>       : integral_constant<size_t,0> {};
template <> struct floating_point_index<double>      : integral_constant<size_t,1> {};
template <> struct floating_point_index<long double> : integral_constant<size_t,2> {};

static constexpr char const * integral_format[]
{
	"%hhd", "%hhu", "%hd", "%hu", "%ld", "%lu", "%lld", "%llu"
};

static constexpr char const * 
floating_point_format[]
{
	"%f", "%lf", "%Lf"
};

static constexpr char const * 
floating_point_scientific_format[]
{
	"%e", "%le", "%Le"
};

static constexpr char const * 
floating_point_generic_format[]
{
	"%g", "%lg", "%Lg"
};

template<typename T> 
struct Hasher 
{};
template<> struct Hasher<bool>       { static constexpr size_t hash(bool value)     noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char>       { static constexpr size_t hash(char value)     noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char16_t>   { static constexpr size_t hash(char16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<char32_t>   { static constexpr size_t hash(char32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<wchar_t>    { static constexpr size_t hash(wchar_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int8_t>     { static constexpr size_t hash(int8_t value)   noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint8_t>    { static constexpr size_t hash(uint8_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int16_t>    { static constexpr size_t hash(int16_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint16_t>   { static constexpr size_t hash(uint16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int32_t>    { static constexpr size_t hash(int32_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint32_t>   { static constexpr size_t hash(uint32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<int64_t>    { static constexpr size_t hash(int64_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<uint64_t>   { static constexpr size_t hash(uint64_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct Hasher<nullptr_t>  { static constexpr size_t hash(nullptr_t)      noexcept { return 0; } };
template<class T> struct Hasher<T *> { static inline    size_t hash(T const * ptr)  noexcept { return size_t(ptr); } };

template<size_t size_> 
struct Hasher<char[size_]>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		static constexpr size_t prime_sq_size = 512;
		auto const & prime_squares = init_prime_squares<size_t,prime_sq_size>();
		if(!pstring)
			return 0;
		size_t hash_ = 0;
		for(size_t i = 0; i < size_ && pstring[i] != '\0'; ++i)
			hash_ += size_t(pstring[i]) * prime_squares[i % prime_sq_size];
		return hash_;
	}

};

template <>
struct Hasher<char[]>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		static constexpr size_t prime_sq_size = 512;
		auto const & prime_squares = init_prime_squares<size_t,prime_sq_size>();
		if(!pstring)
			return 0;
		size_t hash_ = 0;
		for(size_t i = 0; pstring[i] != '\0'; ++i)
			hash_ += size_t(pstring[i]) * prime_squares[i % prime_sq_size];
		return hash_;
	}

};

template<typename T> using hasher = Hasher<T>;

template<typename T> 
struct OrderedHasher 
{};
template<> struct OrderedHasher<bool>        : integral_constant<size_t,max_integral<size_t,false,sizeof(bool)>::value> { static constexpr size_t hash(bool value)     noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char>        : integral_constant<size_t,max_integral<size_t,false,sizeof(char)>::value> { static constexpr size_t hash(char value)     noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char16_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(char16_t)>::value> { static constexpr size_t hash(char16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<char32_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(char32_t)>::value> { static constexpr size_t hash(char32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<wchar_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(wchar_t)>::value> { static constexpr size_t hash(wchar_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int8_t>      : integral_constant<size_t,max_integral<size_t,false,sizeof(int8_t)>::value> { static constexpr size_t hash(int8_t value)   noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint8_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(uint8_t)>::value> { static constexpr size_t hash(uint8_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int16_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int16_t)>::value> { static constexpr size_t hash(int16_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint16_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint16_t)>::value> { static constexpr size_t hash(uint16_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int32_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int32_t)>::value> { static constexpr size_t hash(int32_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint32_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint32_t)>::value> { static constexpr size_t hash(uint32_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<int64_t>     : integral_constant<size_t,max_integral<size_t,false,sizeof(int64_t)>::value> { static constexpr size_t hash(int64_t value)  noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<uint64_t>    : integral_constant<size_t,max_integral<size_t,false,sizeof(uint64_t)>::value> { static constexpr size_t hash(uint64_t value) noexcept { return static_cast<size_t>(value); } };
template<> struct OrderedHasher<nullptr_t>   : integral_constant<size_t,max_integral<size_t>::value> { static constexpr size_t hash(nullptr_t)      noexcept { return 0; } };
template<class T> struct OrderedHasher<T *>  : integral_constant<size_t,max_integral<size_t>::value> { static inline    size_t hash(T const * ptr)  noexcept { return size_t(ptr); } };

template<size_t size_> 
struct OrderedHasher<char[size_]> : integral_constant<size_t,max_integral<size_t>::value>
{

	static size_t 
	hash(char const * pstring) noexcept
	{
		if(!pstring)
			return 0;
		size_t ordered_hash_ = 0;
		size_t min_size = min(sizeof(size_t), size_);
		for(size_t i = 0; i < min_size && pstring[i] != '\0'; ++i)
			ordered_hash_ |= size_t(pstring[i]) << ((sizeof(size_t) - i - 1) * 8);
		return ordered_hash_;
	}

};

template <>
struct OrderedHasher<char[]> : integral_constant<size_t,max_integral<size_t>::value>
{
	static size_t 
	hash(char const * pstring) noexcept
	{
		if(!pstring)
			return 0;
		size_t ordered_hash_ = 0;
		for(size_t i = 0; i < sizeof(size_t) && pstring[i] != '\0'; ++i)
			ordered_hash_ |= size_t(pstring[i]) << ((sizeof(size_t) - i - 1) * 8);
		return ordered_hash_;
	}

};

template<typename T> using ordered_hasher = OrderedHasher<T>;

namespace _ {
	template <typename T, typename E = T
			, typename = decltype(Hasher<E>::hash(decl<T>()))
		> true_type _test_hashable(int); 
	template <typename T, typename E = T> false_type is_hashable(...); 

	template <typename T, typename E = T
			, typename = decltype(OrderedHasher<E>::hash(decl<T>()))
		> true_type _test_ordered_hashable(int); 
	template <typename T, typename E = T> false_type is_ordered_hashable(...); 
} // namespace _

template <typename T, typename E = T> struct is_hashable         : decltype(_::_test_hashable<T,E>(0)) {};
template <typename T, typename E = T> struct is_ordered_hashable : decltype(_::_test_ordered_hashable<T,E>(0)) {};


template <typename T, T... sequence_>
struct integer_sequence 
{};

namespace _ {
	template <typename T, T start_, T end_, bool = (start_ < end_), T i_ = start_, T... sequence_>
	struct integer_sequence_maker 
	{};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,start_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,true,start_+1,sequence_...,start_>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,i_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,true,i_+1,sequence_...,i_>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,true,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,start_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,false,start_-1,sequence_...,start_>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,i_,sequence_...>
	{
		using type = typename integer_sequence_maker<T,start_,end_,false,i_-1,sequence_...,i_>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct integer_sequence_maker<T,start_,end_,false,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, bool = (start_ < end_), T i_ = start_, T... sequence_>
	struct reverse_integer_sequence_maker 
	{};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,start_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,true,start_+1,start_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,i_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,true,i_+1,i_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,true,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};


	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,start_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,false,start_-1,start_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T i_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,i_,sequence_...>
	{
		using type = typename reverse_integer_sequence_maker<T,start_,end_,false,i_-1,i_,sequence_...>::type;
	};

	template <typename T, T start_, T end_, T... sequence_>
	struct reverse_integer_sequence_maker<T,start_,end_,false,end_,sequence_...>
	{
		using type = integer_sequence<T,sequence_...>;
	};
} // namespace _

template <typename T, T start_, T end_> using make_integer_sequence_t         = typename _::integer_sequence_maker<T,start_,end_>::type;
template <typename T, T start_, T end_> using make_reverse_integer_sequence_t = typename _::reverse_integer_sequence_maker<T,start_,end_>::type;
template <size_t... indices_>           using index_sequence                  = integer_sequence<size_t,indices_...>;
template <size_t start_, size_t end_>   using make_index_sequence_t           = typename _::integer_sequence_maker<size_t,start_,end_>::type;
template <size_t start_, size_t end_>   using make_reverse_index_sequence_t   = typename _::reverse_integer_sequence_maker<size_t,start_,end_>::type;


template <size_t index_, typename... Ts>             struct type_at_index                 : type_identity<void> {};
template <size_t index_, typename T, typename... Ts> struct type_at_index<index_,T,Ts...> : type_identity<typename type_at_index<index_-1,Ts...>::type> {};
template <typename T, typename... Ts>                struct type_at_index<0,T,Ts...>      : type_identity<T> {};
template <size_t index_, typename... Ts>             using  type_at_index_t = typename type_at_index<index_,Ts...>::type;


template <typename T, size_t start_ = 0, typename... Ts>         struct type_index                   : integral_constant<size_t,size_t(-1)> {};
template <typename T, size_t start_, typename U, typename... Ts> struct type_index<T,start_,U,Ts...> : integral_constant<size_t,type_index<T,start_+1,Ts...>::value> {};
template <typename T, size_t start_, typename... Ts>             struct type_index<T,start_,T,Ts...> : integral_constant<size_t,start_> {};


// equal to
template <typename L, typename R = L>
struct equal
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs == rhs; } };

// less than
template <typename L, typename R = L>
struct less
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs < rhs; } };

// greater than
template <typename L, typename R = L>
struct greater
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs > rhs; } };

// less than or equal to
template <typename T>
struct less_or_equal
{ constexpr bool operator() (T const & lhs, T const & rhs) const noexcept { return lhs <= rhs; } };

// greater than or equal to
template <typename L, typename R = L>
struct greater_or_equal
{ constexpr bool operator() (L const & lhs, R const & rhs) const noexcept { return lhs >= rhs; } };


/** 
 * forward cast a universal reference.
 * 
 * T __________ T &&
 * T const ____ T const &&
 * T & ________ T &
 * T const & __ T const &
 * T && _______ T &&
 * T const && _ T const &&
 * 
 */
template <typename T> 
DS_nodiscard static constexpr T && 
forward(remove_reference_t<T> & t) noexcept 
{ return static_cast<T &&>(t); }

// cast to T && -- non-const move
// ds::move does not support moving const types unlike std::move
template <typename T, enable_if_t<(!is_const<remove_reference_t<T>>::value),int> = 0>
DS_nodiscard static constexpr remove_reference_t<T> &&
move(T && rhs) noexcept
{
	return static_cast<remove_reference_t<T> &&>(rhs);
}

// cast to T const && -- const move
template <typename T, enable_if_t<(is_const<remove_reference_t<T>>::value),int> = 0>
DS_nodiscard static constexpr remove_reference_t<T> const &&
cmove(T && rhs) noexcept
{
	return static_cast<remove_reference_t<T> const &&>(rhs);
}

// cast to T & -- non-const reference
template <typename T, enable_if_t<(!is_const<remove_reference_t<T>>::value),int> = 0>
static constexpr remove_reference_t<T> &
ref(T && object) noexcept
{
	return static_cast<remove_reference_t<T> &>(object);
}

// cast to T const & -- const reference
template <typename T>
static constexpr remove_reference_t<T> const &
cref(T && object) noexcept
{
	return static_cast<remove_reference_t<T> const &>(object);
}

namespace _ {
	template <typename T
			, typename = decltype(decl<T &>().swap(decl<T &>()))
		> true_type  _has_swap(int);
	template <typename T> false_type _has_swap(...);
} // namespace _

template <typename T> struct has_swap : decltype(_::_has_swap<T>(0)) {};

namespace _ {
	template <typename T
			, bool = has_swap<remove_reference_t<T>>::value
			, bool = is_array<remove_reference_t<T>>::value
			, bool = is_pointer<remove_reference_t<T>>::value
			, bool = (is_move_constructible<remove_reference_t<T>>::value && is_move_assignable<remove_reference_t<T>>::value)
			, bool = (is_copy_constructible<remove_reference_t<T>>::value && is_copy_assignable<remove_reference_t<T>>::value)
		>
	struct _swapper
	{};

	template <typename T, bool b1, bool b2>
	struct _swapper<T,true,false,false,b1,b2>
	{
		static constexpr void
		swap(T & lhs, T & rhs)
		{
			lhs.swap(rhs);
		}
	};

	template <typename T, bool b1, bool b2>
	struct _swapper<T,false,false,true,b1,b2>
	{
		static constexpr void
		swap(T & lhs, T & rhs)
		{
			T tmp = lhs;
			lhs   = rhs;
			rhs   = tmp;
		}
	};

	template <typename T, bool b2>
	struct _swapper<T,false,false,false,true,b2>
	{
		static constexpr void
		swap(T & lhs, T & rhs)
		{
			T tmp = ds::move(lhs);
			lhs   = ds::move(rhs);
			rhs   = ds::move(tmp);
		}
	};

	template <typename T>
	struct _swapper<T,false,false,false,false,true>
	{
		static constexpr void
		swap(T & lhs, T & rhs)
		{
			T tmp = lhs;
			lhs   = rhs;
			rhs   = tmp;
		}
	};
} // namespace _


template <typename T
		, enable_if_t<!is_const<T>::value,int> = 0
		, typename = decltype(_::_swapper<T>::swap(decl<T &>(), decl<T &>()))
	>
static constexpr void
swap(T & lhs, T & rhs) noexcept
{
	_::_swapper<T>::swap(lhs, rhs);
}

template <typename T, enable_if_t<is_const<T>::value,int> = 0>
static constexpr void
swap(T & lhs, T & rhs) noexcept = delete;

namespace _ {
	template <typename T
			, typename = decltype(ds::swap(decl<T &>(), decl<T &>()))
		> true_type  _is_swappable(int);
	template <typename T> false_type _is_swappable(...);
} // namespace _

template <typename T> struct is_swappable : decltype(_::_is_swappable<T>(0)) {};


static inline size_t
aligned_offset(void * block_, align_t align_)
{
	return (~size_t(block_)+1) & (--align_);
}


template <typename T, bool = is_destructible<T>::value && !is_trivially_destructible<T>::value>
struct safe_destructor
{
	static constexpr void destruct(T & object) { object.~T(); }
};

template <typename T>
struct safe_destructor<T,false>
{
	static constexpr void destruct(T & object) {}
};

template <typename T>
static constexpr void
destruct(T & object)
{
	return safe_destructor<T>::destruct(object);
}

template <typename T, typename... Args, enable_if_t<is_constructible<T,Args...>::value,int> = 0>
static inline T *
construct_at(void * addr, Args &&... args)
{
	return new (addr) T(ds::forward<Args>(args)...);
}

template <typename T, typename... Args, enable_if_t<is_constructible<T,Args...>::value,int> = 0>
static inline T *
construct_at_safe(void * addr, Args &&... args)
{
	return addr == nullptr 
		? nullptr 
		: new (addr) T(ds::forward<Args>(args)...);
}


template <typename T, typename S = T>
struct Sequence
{
	T value = 0;
	S step  = 1;

	constexpr Sequence() = default;

	constexpr Sequence(T start_)
		: value { ds::move(start_) }
	{}

	constexpr Sequence(T start_, S step_)
		: value { ds::move(start_) }
		, step  { ds::move(step_)  }
	{}

	constexpr operator T () noexcept 
	{
		auto next_ = value;
		value += step;
		return next_;
	}

};


struct FlushTo
{
	FILE * _file = nullptr;

	FlushTo() = default;

	FlushTo(FILE * file_)
		: _file { file_ }
	{}

};

static thread_local FlushTo flush { stdout };

using flush_to = FlushTo; 

struct EndLine
{
	FILE * _file = nullptr;

	EndLine() = default;

	EndLine(FILE * file_)
		: _file { file_ }
	{}

};

static thread_local EndLine endl { stdout };

using end_line = EndLine;

static constexpr size_t 
string_length(char const * pstring_) noexcept
{
	size_t length_ = 0;
	for(; pstring_[length_] != '\0'; ++length_);
	return length_;
}

static constexpr size_t 
string_length(char const * pstring_, size_t max_) noexcept
{
	size_t length_ = 0;
	for(; length_ < max_ && pstring_[length_++] != '\0'; ++length_);
	return length_;
}


static constexpr int
string_compare(char const * lhs, char const * rhs) noexcept
{
	size_t i = 0;
	for(; lhs[i] != '\0' && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return lhs[i] == rhs[i]
		? 0 
		: rhs[i] != '\0'
			? -1 
				: lhs[i] != '\0';
}

static constexpr int
string_compare(char const * lhs, char const * rhs, size_t size_) noexcept
{
	size_t i = 0;
	for(; i < size_ && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return i == size_ && rhs[i] == '\0' 
		? 0
		: rhs[i] != '\0' 
			? -1 
			: i != size_;
}

static constexpr int
string_compare(char const * lhs, char const * rhs, size_t lsize, size_t rsize) noexcept
{
	size_t i = 0;
	for(; i < lsize && i < rsize; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return i == lsize && i == rsize
		? 0
		: i == lsize
			? -1 
			: i == rsize;
}

static constexpr int
string_partial_compare(char const * lhs, char const * rhs) noexcept
{
	size_t i = 0;
	for(; lhs[i] != '\0' && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return 0;
}

static constexpr int
string_partial_compare(char const * lhs, char const * rhs, size_t size_) noexcept
{
	size_t i = 0;
	for(; i < size_ && rhs[i] != '\0'; ++i)
	{
		if(lhs[i] < rhs[i])
			return -1;
		else if(lhs[i] > rhs[i])
			return 1;
	}
	return 0;
}

static constexpr int
string_partial_compare(char const * lhs, char const * rhs, size_t lsize, size_t rsize) noexcept
{
	return string_partial_compare(lhs, rhs, min(lsize, rsize));
}

template <typename E, size_t size_> static constexpr size_t size(E (& array_)[size_])       { return size_; }
template <typename E, size_t size_> static constexpr size_t size(E const (& array_)[size_]) { return size_; }

template <typename E, size_t size_> static constexpr E       * begin(E (& array_)[size_])       { return &array_[0]; }
template <typename E, size_t size_> static constexpr E       * end(E (& array_)[size_])         { return &array_[size_]; }
template <typename E, size_t size_> static constexpr E const * begin(E const (& array_)[size_]) { return &array_[0]; }
template <typename E, size_t size_> static constexpr E const * end(E const (& array_)[size_])   { return &array_[size_]; }

template <class C, typename sz_t = decltype(decl<C &>().size())>       static constexpr sz_t size(C & object_)           { return object_.size(); }
template <class C, typename sz_t = decltype(decl<C const &>().size())> static constexpr sz_t size(C const & object_)     { return object_.size(); }


template <class C, typename it_t = decltype(decl<C &>().begin())>       static constexpr it_t begin(C & object_)         { return object_.begin(); }
template <class C, typename it_t = decltype(decl<C &>().end())>         static constexpr it_t end(C & object_)           { return object_.end(); }
template <class C, typename it_t = decltype(decl<C const &>().begin())> static constexpr it_t begin(C const & object_)   { return object_.begin(); }
template <class C, typename it_t = decltype(decl<C const &>().end())>   static constexpr it_t end(C const & object_)     { return object_.end(); }

template <class C, typename it_t = decltype(decl<C &>().rbegin())>       static constexpr it_t rbegin(C & object_)       { return object_.rbegin(); }
template <class C, typename it_t = decltype(decl<C &>().rend())>         static constexpr it_t rend(C & object_)         { return object_.rend(); }
template <class C, typename it_t = decltype(decl<C const &>().rbegin())> static constexpr it_t rbegin(C const & object_) { return object_.rbegin(); }
template <class C, typename it_t = decltype(decl<C const &>().rend())>   static constexpr it_t rend(C const & object_)   { return object_.rend(); }

namespace traits {
	template <typename T> struct iterable;
} // namespace traits

template <class C, typename E>
struct inserter
{
	// C & container;
	// bool init(size_t required_size);
	// template <typename T>
	// bool insert(T && object);
};

namespace _ {
	template <class C, typename E
			, typename = decltype(decl<ds::inserter<C,E>>().insert(decl<E>()))
		> true_type has_inserter(int);
	template <class C, typename E> false_type has_inserter(...);
} // namespace _

template <class C, typename E> struct has_inserter : decltype(_::has_inserter<C,E>(0)) {};

template <class C, typename E = typename traits::iterable<C>::element_t>
using inserter_t = conditional_t<has_inserter<remove_reference_t<C>,E>::value
		, ds::inserter<C,E>
		, void
	>;


template <typename K, typename V>
struct Entry
{
	K const key   {};
	V       value {};

	constexpr Entry() = default;
	constexpr Entry(Entry &&) = default;
	constexpr Entry(Entry const &) = default;
	Entry & operator=(Entry &&) = default;
	Entry & operator=(Entry const &) = default;

	template <typename K_ = K, enable_if_t<is_constructible<K,K_>::value,int> = 0>
	constexpr explicit Entry(K_ && key_)
		: key   { ds::forward<K_>(key_) }
	{}

	template <typename K_ = K, typename V_ = V
			, enable_if_t<is_constructible<K,K_>::value,int> = 0
			, enable_if_t<is_constructible<V,V_>::value,int> = 0>
	constexpr Entry(K_ && key_, V_ && value_)
		: key   { ds::forward<K_>(key_) }
		, value { ds::forward<V_>(value_) }
	{}

	template <typename = decltype(decl<K>() == decl<K>())>
	constexpr bool 
	operator==(Entry const & rhs) const noexcept
	{ return key == rhs.key; }

	template <typename = decltype(decl<K>() == decl<K>())>
	constexpr bool 
	operator==(K const & key_) const noexcept
	{ return key == key_; }

	template <typename T, typename = decltype(decl<K>() == decl<T>())>
	constexpr bool 
	operator==(T && key_) const noexcept
	{ return key == key_; }

	template <typename = decltype(decl<K>() < decl<K>())>
	constexpr bool 
	operator<(Entry const & rhs) const noexcept
	{ return key < rhs.key; }

	template <typename = decltype(decl<K>() < decl<K>())>
	constexpr bool 
	operator<(K const & key_) const noexcept
	{ return key < key_; }

	template <typename T, typename = decltype(decl<K>() < decl<T>())>
	constexpr bool 
	operator<(T && key_) const noexcept
	{ return key < key_; }

};

template <typename K, typename V> using entry = Entry<K,V>;

template <typename K, typename V>
struct Hasher<Entry<K,V>>
{
	static inline size_t hash(Entry<K,V> const & s) { return Hasher<K>::hash(s.key); }
	static inline size_t hash(K const & key) { return Hasher<K>::hash(key); }
	template <typename T, typename = decltype(Hasher<K>::hash(decl<T>()))>
	static inline size_t hash(T && key) { return Hasher<K>::hash(key); }
};

template <typename K, typename V>
struct OrderedHasher<Entry<K,V>> : integral_constant<size_t,OrderedHasher<K>::value>
{
	static inline size_t hash(Entry<K,V> const & s) { return OrderedHasher<K>::hash(s.key); }
	static inline size_t hash(K const & key) { return OrderedHasher<K>::hash(key); }
	template <typename T, typename = decltype(OrderedHasher<K>::hash(decl<T>()))>
	static inline size_t hash(T && key) { return OrderedHasher<K>::hash(key); }
};

static thread_local char const * stream_separator = ", ";
static thread_local char const * stream_separator_key_value = ": ";

template <class OST, typename K, typename V
		, enable_if_t<is_out_streamable<OST,K>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,V>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,char const *>::value,int> = 0
	>
static OST & 
operator<<(OST && ost, ds::Entry<K,V> const & rhs)
{
	return ost << rhs.key << stream_separator_key_value << rhs.value;
}


template <class OST, typename C
		, typename IT = decltype(decl<C const &>().begin())
		, typename ET = decltype(*decl<IT &>())
		, typename    = decltype(decl<C const &>().end())
		, typename    = decltype(++decl<IT &>())
		, enable_if_t<is_out_streamable<OST,ET>::value,int> = 0
		, enable_if_t<is_out_streamable<OST,char const *>::value,int> = 0
	>
static OST & 
operator<<(OST && ost, C const & rhs)
{
	auto end_ = rhs.end();
	for(auto it = rhs.begin();;)
	{
		ost << *it;
		if(++it != end_)
			ost << stream_separator;
		else 
			break;
	}
	return ost;
}

enum class duplicate_rule
{
	Default   = 1, // same as Allow.
	Allow     = 1, // Allow duplicates.
	Unique    = 2, // No duplicates but no replacing.
	Replace   = 3, // Replace duplicates.
};

// returns the upper-case hexadecimal representation of 'value' 0-F
// truncates on overflow to max. i.e. F
static constexpr char
hex_char(uint8_t value) 
{
	return value <= 9 ? ('0' + value) : (value <= 15 ? ('A' + value - 10) : 'F');
}

// returns the lower-case hexadecimal representation of 'value' 0-f
// truncates on overflow to max. i.e. f
static constexpr char
hex_char_lower(uint8_t value) 
{
	return value <= 9 ? ('0' + value) : (value <= 15 ? ('a' + value - 10) : 'f');
}

// returns the base-10 value of 'hex_char' which is expected to be a hexadecimal ([0-F]|[0-f])
// returns 0 on invalid input
static constexpr uint8_t  
hex_value(char hex_char) 
{
	if(hex_char >= '0' && hex_char <= '9')
		return uint8_t(hex_char - '0');
	else if(hex_char >= 'a' && hex_char <= 'f')
		return 10 + uint8_t(hex_char - 'a');
	else if(hex_char >= 'A' && hex_char <= 'F')
		return 10 + uint8_t(hex_char - 'A');
	else
		return 0;
}

// efficient reverse.
template<typename It> 
static constexpr void
reverse(It begin_, It end_)
{
	if(begin_ == end_)
		return;
	while(begin_ != --end_)
	{
		ds::swap(*begin_, *end_);
		if(++begin_ == end_)
			break;
	}
}

// efficient reverse.
template <typename T
		, typename = decltype(begin(decl<T>()))
		, typename = decltype(end(decl<T>()))
	>
static constexpr void
reverse(T && f_iterable)
{
	ds::reverse(ds::begin(f_iterable), ds::end(f_iterable));
}

namespace _ {
	template <typename E, class C>
	static constexpr void
	_sort2(E & a, E & b, C && compare)
	{
		if(compare(b, a))
			ds::swap(a, b);
	}

	template <typename E, class C>
	static constexpr void
	_sort3(E & a, E & b, E & c, C && compare)
	{
		if(compare(a, b))
		{
			if(compare(a, c))
			{
				if(compare(c, b))
					ds::swap(b, c);
			}
			else
			{
				ds::swap(a, b);
				ds::swap(a, c);
			}
		}
		else
		{
			if(compare(a, c))
			{
				ds::swap(a, b);
			}
			else
			{
				ds::swap(a, c);
				if(compare(b, a))
					ds::swap(a, b);
			}
		}
	}

	template <typename E, class C>
	static constexpr void
	_sort4(E & a, E & b, E & c, E & d, C && compare)
	{
		if(compare(a, b))
		{
			if(compare(a, c))
			{
				if(compare(a, d))
				{
					_sort3(b, c, d, compare);
				}
				else
				{
					ds::swap(a, d);
					_sort3(b, c, d, compare);
				}
			}
			else
			{
				if(compare(d, c))
				{
					ds::swap(a, d);
					_sort3(b, c, d, compare);
				}
				else
				{
					ds::swap(a, c);
					_sort3(b, c, d, compare);
				}
			}
		}
		else
		{
			if(compare(b, c))
			{
				if(compare(b, d))
				{
					ds::swap(a, b);
					_sort3(b, c, d, compare);
				}
				else
				{
					ds::swap(a, d);
					_sort3(b, c, d, compare);
				}
			}
			else
			{
				if(compare(d, c))
				{
					ds::swap(a, d);
					_sort3(b, c, d, compare);
				}
				else
				{
					ds::swap(a, c);
					_sort3(b, c, d, compare);
				}
			}
		}
	}
} // namespace _

// a very quick quick-sort.
template<typename It, class C = less<decltype(*decl<It &>())>
		, enable_if_t<is_integral<decltype(decl<It &>() - decl<It &>())>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() < decl<It &>()),bool>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() - size_t(1)),It>::value,int> = 0
		, enable_if_t<is_same<decltype(decl<It &>() + size_t(1)),It>::value,int> = 0
	> 
static constexpr void 
sort(It begin_, It end_, C && compare = {}) noexcept
{
	if(begin_ + 1 < end_)
	{
		auto size_ = size_t(end_ - begin_);
		if(size_ == 2)
			_::_sort2(*begin_, *(begin_+1), compare);
		else if(size_ == 3)
			_::_sort3(*begin_, *(begin_+1), *(begin_+2), compare);
		else if(size_ == 4)
			_::_sort4(*begin_, *(begin_+1), *(begin_+2), *(begin_+3), compare);
		else 
		{
			// check if sorted
			{
				auto last_ = end_ - 1;
				bool sorted         = true;
				bool reverse_sorted = true;
				for(It it = begin_; it < last_; ++it)
				{
					if(sorted && compare(*(it+1), *it))
					{
						sorted = false;
						if(!reverse_sorted)
							break;
					}
					else if(reverse_sorted && compare(*it, *(it+1)))
					{
						reverse_sorted = false;
						if(!sorted)
							break;
					}
				}
				if(sorted)
					return;
				else if(reverse_sorted)
				{
					ds::reverse(begin_, end_);
					return;
				}
			}
			// sort
			{
				ds::swap(*begin_, *(begin_+3));
				It pivot = begin_;
				It left  = begin_ + 1;
				It right = end_ - 1;
				while(left < right)
				{
					while(left < right && compare(*left, *pivot))
						++left;
					while(left <= right && !compare(*right, *pivot))
						--right;
					if(left < right)
					{
						ds::swap(*left, *right);
						++left;
						--right;
					}
				}
				if(right != pivot)
				{
					if(compare(*left, *pivot))
						ds::swap(*pivot, *left);
					else
						ds::swap(*pivot, *(--left));
				}
				else
					--left;
				ds::sort(begin_, left, compare);
				ds::sort(left + 1, end_, compare);
			}
		}
	}
}


// a very quick quick-sort.
template <typename T, class C = less<decltype(*decl<T &>().begin())>
		, typename = decltype(size(decl<T>()))
		, typename = decltype(begin(decl<T>()))
		, typename = decltype(rbegin(decl<T>()))
	>
static constexpr void
sort(T && fr_iterable, C && compare = {})
{
	ds::sort(begin(fr_iterable), end(fr_iterable), ds::forward<C>(compare));
}


template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(begin(decl<T const &>()))
		, typename UB = decltype(begin(decl<U const &>()))
		, typename    = decltype(end(decl<T const &>()))
		, typename    = decltype(end(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(++decl<TB &>())
		, typename    = decltype(++decl<UB &>())
	>
static constexpr bool
begins_with(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lit = begin(lhs);
	auto ren = end(rhs);
	for(auto rit = begin(rhs); rit != ren; ++rit, ++lit)
		if(*rit != *lit)
			return false;
	return true;
}

template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(rbegin(decl<T const &>()))
		, typename UB = decltype(rbegin(decl<U const &>()))
		, typename    = decltype(rend(decl<T const &>()))
		, typename    = decltype(rend(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(--decl<TB &>())
		, typename    = decltype(--decl<UB &>())
	>
static constexpr bool
ends_with(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lit = rbegin(lhs);
	auto ren = rend(rhs);
	for(auto rit = rbegin(rhs); rit != ren; --rit, --lit)
		if(*rit != *lit)
			return false;
	return true;
}

template <typename T, typename U
		, typename    = decltype(size(decl<T const &>()))
		, typename    = decltype(size(decl<U const &>()))
		, typename TB = decltype(begin(decl<T const &>()))
		, typename UB = decltype(begin(decl<U const &>()))
		, typename    = decltype(end(decl<T const &>()))
		, typename    = decltype(end(decl<U const &>()))
		, typename    = decltype(*decl<TB &>())
		, typename    = decltype(*decl<UB &>())
		, typename    = decltype(++decl<TB &>())
		, typename    = decltype(++decl<UB &>())
	>
static constexpr bool
contians(T const & lhs, U const & rhs) noexcept
{
	size_t lsize = size(lhs);
	size_t rsize = size(rhs);
	if(lsize < rsize)
		return false;
	auto lend = end(lhs);
	auto rend = end(rhs);
	for(auto lit = begin(lhs); lit != lend; ++lit)
	{
		bool match_ = true;
		auto lit2 = lit;
		for(auto rit = begin(rhs); rit != rend; ++rit, ++lit2) 
			if(*lit2 != *rit)
				match_ = false;
		if(match_)
			return true;
	}
	return false;
}

template <size_t lsize_, size_t rsize_>
static constexpr bool
contians(char const (& lhs)[lsize_], char const (& rhs)[rsize_]) noexcept
{
	size_t lsize = lsize_ - 1;
	size_t rsize = rsize_ - 1;
	if(lsize < rsize)
		return false;
	auto lend = &lhs[lsize];
	auto rend = &rhs[rsize];
	for(auto lit = &lhs[0]; lit != lend; ++lit)
	{
		bool match_ = true;
		auto lit2 = lit;
		for(auto rit = &rhs[0]; rit != rend; ++rit, ++lit2) 
			if(*lit2 != *rit)
				match_ = false;
		if(match_)
			return true;
	}
	return false;
}

} // namespace ds

#endif // DS_COMMON
