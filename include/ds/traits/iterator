#pragma once
#ifndef DS_TRAITS_ITERATOR
#define DS_TRAITS_ITERATOR

#include "../common"

namespace ds {
	
template <
	typename _element_t = void,
	typename _indexable_iterator_t        = void,
	typename _const_indexable_iterator_t  = void const,
	typename _forward_iterator_t          = void,
	typename _const_forward_iterator_t    = void const,
	typename _reverse_iterator_t          = void,
	typename _const_reverse_iterator_t    = void const
>
struct iterator_traits
{
	using element_t                  = _element_t;
	using indexable_iterator_t       = _indexable_iterator_t;
	using const_indexable_iterator_t = _const_indexable_iterator_t;
	using forward_iterator_t         = _forward_iterator_t;
	using const_forward_iterator_t   = _const_forward_iterator_t;
	using reverse_iterator_t         = _reverse_iterator_t;
	using const_reverse_iterator_t   = _const_reverse_iterator_t;
};

namespace traits {


template <typename T>
struct iterator : public ds::iterator_traits<> {};

template <typename E, size_t size_>
struct iterator<E[size_]> : public ds::iterator_traits<E,E *,E const *,E *,E const *> {};

template <typename E, size_t size_>
struct iterator<E const[size_]> : public ds::iterator_traits<E,void,E const *,void,E const *> {};

template <template <typename...> class C, typename E, typename... Args>
struct iterator<C<E,Args...>> : public ds::iterator_traits<
	  decltype(*ds::decl<C<E,Args...>>().begin())
	, decltype(&ds::decl<C<E,Args...>>()[0])
	, decltype(&ds::decl<C<E,Args...> const>()[0])
	, decltype(ds::decl<C<E,Args...>>().begin())
	, decltype(ds::decl<C<E,Args...> const>().begin())
	, decltype(ds::decl<C<E,Args...>>().rbegin())
	, decltype(ds::decl<C<E,Args...> const>().rbegin())
>
{};

template <template <typename,size_t> class C, typename E, size_t size_>
struct iterator<C<E,size_>> : public ds::iterator_traits<
	  decltype(*ds::decl<C<E,size_>>().begin())
	, decltype(&ds::decl<C<E,size_>>()[0])
	, decltype(&ds::decl<C<E,size_> const>()[0])
	, decltype(++ds::decl<C<E,size_>>().begin())
	, decltype(++ds::decl<C<E,size_> const>().begin())
	, decltype(--ds::decl<C<E,size_>>().rbegin())
	, decltype(--ds::decl<C<E,size_> const>().rbegin())
>
{};


} // namespace traits

template <typename T>
struct has_element
{
	static constexpr bool value = !ds::is_same<typename ds::traits::iterator<T>::element_t,void>::value;
};

template <typename T>
struct has_indexable_iterator
{
	static constexpr bool value = !ds::is_same<typename ds::traits::iterator<T>::indexable_iterator_t,void>::value;
};

template <typename T>
struct has_const_indexable_iterator
{
	static constexpr bool value = !ds::is_same<typename ds::traits::iterator<T>::const_indexable_iterator_t,void const>::value;
};

template <typename T>
struct has_forward_iterator
{
	static constexpr bool value = !ds::is_same<typename ds::traits::iterator<T>::forward_iterator_t,void>::value;
};

template <typename T>
struct has_const_forward_iterator
{
	static constexpr bool value = !ds::is_same<typename ds::traits::iterator<T>::const_forward_iterator_t,void const>::value;
};

template <typename T>
struct has_reverse_iterator
{
	static constexpr bool value = !ds::is_same<typename ds::traits::iterator<T>::reverse_iterator_t,void>::value;
};

template <typename T>
struct has_const_reverse_iterator
{
	static constexpr bool value = !ds::is_same<typename ds::traits::iterator<T>::const_reverse_iterator_t,void const>::value;
};


template <typename T>
using iterator_element_t = typename ds::traits::iterator<ds::remove_reference_t<T>>::element_t;

template <typename T>
using iterator_indexable_t = typename ds::traits::iterator<ds::remove_reference_t<T>>::indexable_iterator_t;

template <typename T>
using const_iterator_indexable_t = typename ds::traits::iterator<ds::remove_reference_t<T>>::const_indexable_iterator_t;

template <typename T>
using iterator_forward_t = typename ds::traits::iterator<ds::remove_reference_t<T>>::forward_iterator_t;

template <typename T>
using const_iterator_forward_t = typename ds::traits::iterator<ds::remove_reference_t<T>>::const_forward_iterator_t;

template <typename T>
using iterator_reverse_t = typename ds::traits::iterator<ds::remove_reference_t<T>>::reverse_iterator_t;

template <typename T>
using const_iterator_reverse_t = typename ds::traits::iterator<ds::remove_reference_t<T>>::const_reverse_iterator_t;


} // namespace ds

#endif // DS_TRAITS_ITERATOR
