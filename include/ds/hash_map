#pragma once
#ifndef DS_HASH_MAP
#define DS_HASH_MAP

#include "common"
#include "hash_list"

namespace ds {

template <typename K, typename V> 
struct Entry;
template <size_t table_size_, typename K, typename V, class A = DefaultAllocator> 
using HashMapIterator = HashList<table_size_,Entry<K,V>,A>;
template <size_t table_size_, typename K, typename V, class A = DefaultAllocator> 
using ConstHashMapIterator = HashList<table_size_,Entry<K,V>,A>;
template <size_t table_size_, typename K, typename V, class A = DefaultAllocator> 
class HashMap;

namespace traits {

	template <size_t table_size_, typename K, typename V, class A>
	struct iterable<HashMap<table_size_,K,V,A>> : public iterable<HashList<table_size_,Entry<K,V>,A>> {};

	template <size_t table_size_, typename K, typename V, class A>
	struct iterable<HashMap<table_size_,K,V,A> const> : public iterable<HashList<table_size_,Entry<K,V>,A> const> {};

	template <size_t table_size_, typename K, typename V, class A>
	struct allocator<HashMap<table_size_,K,V,A>> : public allocator_traits<A> {};

	template <size_t table_size_, typename K, typename V, class A>
	struct allocator<HashMap<table_size_,K,V,A> const> : public allocator_traits<A> {};

} // namespace trait

template <typename K, typename V>
struct Entry
{
	K const key   {};
	V       value {};

	Entry() = default;
	Entry(Entry &&) = default;
	Entry(Entry const &) = default;
	Entry & operator=(Entry &&) = default;
	Entry & operator=(Entry const &) = default;

	template <typename K_ = K, enable_if_t<is_constructible<K,K_>::value,int> = 0>
	Entry(K_ && key_)
		: key   { ds::forward<K_>(key_) }
	{}

	template <typename K_ = K, typename V_ = V
			, enable_if_t<is_constructible<K,K_>::value,int> = 0
			, enable_if_t<is_constructible<V,V_>::value,int> = 0>
	Entry(K_ && key_, V_ && value_)
		: key   { ds::forward<K_>(key_) }
		, value { ds::forward<V_>(value_) }
	{}

	constexpr bool 
	operator==(Entry const & rhs) const noexcept
	{ return key == rhs.key; }

	constexpr bool 
	operator==(K const & key_) const noexcept
	{ return key == key_; }

	template <typename T, typename = decltype(decl<K>() == decl<T>())>
	constexpr bool 
	operator==(T && key_) const noexcept
	{ return key == key_; }

};

template <typename K, typename V>
struct Hasher<Entry<K,V>>
{
	static inline size_t hash(Entry<K,V> const & s) { return Hasher<K>::hash(s.key); }
	static inline size_t hash(K const & key) { return Hasher<K>::hash(key); }
	template <typename T, typename = decltype(Hasher<K>::hash(decl<T>()))>
	static inline size_t hash(T && key) { return Hasher<K>::hash(key); }
};

using hash_map_param = hash_list_param;

template <size_t table_size_, typename K, typename V, class A>
class HashMap : protected HashList<table_size_,Entry<K,V>,A>
{
 public:
	using key_t            = K;
	using value_t          = V;
	using entry_t          = Entry<K,V>;
	using iterator_t       = typename HashList<table_size_,Entry<K,V>,A>::iterator_t;
	using const_iterator_t = typename HashList<table_size_,Entry<K,V>,A>::const_iterator_t;

 public:
	HashMap() = default;
	HashMap(HashMap &&) = default;
	HashMap(HashMap const &) = default;
	HashMap & operator=(HashMap &&) = default;
	HashMap & operator=(HashMap const &) = default;

	template <size_t size_
		, enable_if_t<is_constructible<HashList<table_size_,entry_t,A>,entry_t(&&)[size_],hash_list_param>::value,int> = 0>
	HashMap(entry_t (&& array_)[size_], hash_map_param param = {})
		: HashList<table_size_,entry_t,A>(ds::move(array_), param)
	{}

	template <typename Begin, typename End
		, typename T = decltype(*decl<Begin &>())
		, typename   = decltype(++decl<Begin &>())
		, enable_if_t<is_constructible<entry_t,T>::value,int> = 0>
	HashMap(Begin && begin_, End && end_, hash_map_param param = {})
		: HashList<table_size_,entry_t,A>(ds::forward<Begin>(begin_), ds::forward<End>(end_), param)
	{}

	template <typename K_, typename = decltype(Hasher<entry_t>::hash(decl<K_>()))>
	value_t & 
	operator[](K_ && key)
	{
		return this->insert_replace(ds::forward<K_>(key))->value;
	}

	template <typename K_, typename = decltype(Hasher<entry_t>::hash(decl<K_>()))>
	value_t & 
	operator[](K_ && key) const noexcept
	{
		return this->position_of(ds::forward<K_>(key))->value;
	}

	template <typename K_, typename V_
			, enable_if_t<is_constructible<entry_t,K_,V_>::value,int> = 0
			, typename = decltype(Hasher<entry_t>::hash(decl<K_>()))
		>
	inline iterator_t
	set(K_ && key, V_ && value)
	{
		return this->emplace_replace(ds::forward<K_>(key), ds::forward<V_>(value));
	}

	template <typename K_, typename V_
		, enable_if_t<is_constructible<entry_t,K_,V_>::value,int> = 0
		, typename = decltype(Hasher<entry_t>::hash(decl<K_>()))>
	inline iterator_t
	set_noreplace(K_ && key, V_ && value)
	{
		return this->emplace_unique(ds::forward<K_>(key), ds::forward<V_>(value));
	}

	template <typename K_, typename = decltype(Hasher<entry_t>::hash(decl<K_>()))>
	iterator_t
	get(K_ && key) noexcept
	{
		return this->position_of(ds::forward<K_>(key));
	}

	template <typename K_, typename = decltype(Hasher<entry_t>::hash(decl<K_>()))>
	const_iterator_t
	get(K_ && key) const noexcept
	{
		return this->position_of(ds::forward<K_>(key));
	}

	using HashList<table_size_,entry_t,A>::operator!;
	using HashList<table_size_,entry_t,A>::operator bool;
	using HashList<table_size_,entry_t,A>::table;
	using HashList<table_size_,entry_t,A>::size;
	using HashList<table_size_,entry_t,A>::begin;
	using HashList<table_size_,entry_t,A>::end;
	using HashList<table_size_,entry_t,A>::rbegin;
	using HashList<table_size_,entry_t,A>::rend;
	using HashList<table_size_,entry_t,A>::remove_at;
	using HashList<table_size_,entry_t,A>::remove;
	using HashList<table_size_,entry_t,A>::swap;

};


template <typename K, typename V>
using entry = Entry<K,V>;

template <size_t table_size_, typename K, typename V, class A = ds::DefaultAllocator>
using hash_map = HashMap<table_size_,K,V,A>;


} // namespace ds

#endif // DS_HASH_MAP
