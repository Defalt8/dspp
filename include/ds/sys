#pragma once
#ifndef DS_SYS
#define DS_SYS

#include <cerrno>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef _WIN32
#	ifndef WIN32_LEAN_AND_MEAN
#		define WIN32_LEAN_AND_MEAN
#	endif
#	include <Windows.h>
#	include <direct.h>
#	include <io.h>
#else
#	include <dirent.h>
#	include <unistd.h>
#endif

#include "common"
#include "string"
#include "list"

namespace ds {
namespace sys {

  #ifdef _WIN32
	static constexpr size_t max_path = 260;
  #else
	static constexpr size_t max_path = PATH_MAX;
  #endif

	namespace _ {
		static inline
		StringView
		_terminate_path(StringView const & path_, char (& buffer)[max_path+1])
		{
			auto path_size = path_.size();
			if(path_size > 0 && path_size <= max_path && path_[path_size] != '\0')
			{
				memcpy(&buffer[0], path_.begin(), path_size);
				buffer[path_size] = '\0';
				return { &buffer[0], path_size };
			}
			return path_;
		}
	} // namespace _

	static bool
	exists(StringView const & path)
	{
		if(path.size() > 0 && path.size() <= max_path)
		{
		  #ifdef _WIN32
			return _access(path.begin(), 0) == 0;
		  #else
			return access(path.begin(), 0) == 0;
		  #endif
		}
		return false;
	}

	enum class type
	{
		does_not_exist = 0, // not available 
		dir, 
		regular_file, 
		pipe, 
		char_special, 
		other_file,
		other
	};

	static type
	get_type(StringView const & path_)
	{
		if(path_.size() > 0 && path_.size() <= max_path)
		{
			char _path_buffer[max_path+1];
			auto path = _::_terminate_path(path_, _path_buffer);
		  #ifdef _MSC_VER
			if(_access(path.begin(), 0) == 0)
		 	{
				struct _stat64i32 status {};
				_stat(path.begin(), &status);
				if((status.st_mode & _S_IFDIR) != 0)
					return type::dir;
				else if((status.st_mode & _S_IFREG) != 0)
					return type::regular_file;
				else if((status.st_mode & _S_IFIFO) != 0)
					return type::pipe;
				else if((status.st_mode & _S_IFCHR) != 0)
					return type::char_special;
				else if((status.st_mode & (_S_IFMT & ~_S_IFDIR)) != 0)
					return type::other_file;
				else
					return type::other;
			}
		  #else
			if(access(path.begin(), 0) == 0)
		 	{
				struct stat status;
				stat(path.begin(), &status);
				if((status.st_mode & S_IFDIR) != 0)
					return type::dir;
				else if((status.st_mode & S_IFREG) != 0)
					return type::regular_file;
				else if((status.st_mode & S_IFIFO) != 0)
					return type::pipe;
				else if((status.st_mode & S_IFCHR) != 0)
					return type::char_special;
				else if((status.st_mode & (S_IFMT & ~S_IFDIR)) != 0)
					return type::other_file;
				else
					return type::other;
			}
		  #endif
		}
		return type::does_not_exist;
	}

	static bool 
	is_dir(StringView const & path_)
	{
		if(path_.size() > 0 && path_.size() <= max_path)
		{
			char _path_buffer[max_path+1];
			auto path = _::_terminate_path(path_, _path_buffer);
		  #ifdef _MSC_VER
			if(_access(path.begin(), 0) == 0)
		 	{
				struct _stat64i32 status {};
				_stat(path.begin(), &status);
				return (status.st_mode & _S_IFDIR) != 0;
			}
		  #else
			if(access(path.begin(), 0) == 0)
		 	{
				struct stat status;
				stat(path.begin(), &status);
				return (status.st_mode & S_IFDIR) != 0;
			}
		  #endif
		}
		return false;
	}

	static bool
	is_file(StringView const & path_)
	{
		if(path_.size() > 0 && path_.size() <= max_path)
		{
			char _path_buffer[max_path+1];
			auto path = _::_terminate_path(path_, _path_buffer);
		  #ifdef _MSC_VER
			if(_access(path.begin(), 0) == 0)
		 	{
				struct _stat64i32 status {};
				_stat(path.begin(), &status);
				return (status.st_mode & (_S_IFMT & ~_S_IFDIR)) != 0;
			}
		  #else
			if(access(path.begin(), 0) == 0)
		 	{
				struct stat status;
				stat(path.begin(), &status);
				return (status.st_mode & (S_IFMT & ~S_IFDIR)) != 0;
			}
		  #endif
		}
		return false;
	}

	static bool
	is_regular_file(StringView const & path_)
	{
		if(path_.size() > 0 && path_.size() <= max_path)
		{
			char _path_buffer[max_path+1];
			auto path = _::_terminate_path(path_, _path_buffer);
		  #ifdef _MSC_VER
			if(_access(path.begin(), 0) == 0)
		 	{
				struct _stat64i32 status {};
				_stat(path.begin(), &status);
				return (status.st_mode & (_S_IFMT & _S_IFREG)) != 0;
			}
		  #else
			if(access(path.begin(), 0) == 0)
		 	{
				struct stat status;
				stat(path.begin(), &status);
				return (status.st_mode & (S_IFMT & S_IFREG)) != 0;
			}
		  #endif
		}
		return false;
	}

	enum class smkdir
	{
		ok = 0,
		file_exists,
		invalid_path,
		name_too_long,
		access_denied,
		not_enough_space,
		other
	};

	static smkdir
	mkdir(StringView const & path_) noexcept
	{
		if(path_.size() > 0)
		{
			if(path_.size() > max_path)
				return smkdir::name_too_long;
			else
			{
				char _path_buffer[max_path+1];
				auto path = _::_terminate_path(path_, _path_buffer);
				int _err;
			  #if defined(_WIN32)
				_err = ::_mkdir(path.begin());
			  #else 
				_err = ::mkdir(path.begin(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
			  #endif
			  	if(_err == 0)
					return smkdir::ok;
				_err = int(errno);
				if(_err == EEXIST && is_dir(path.begin()))
					return smkdir::ok;
				else if(_err == ENOENT && path.size() > max_path)
					return smkdir::name_too_long;
				else if(_err == EEXIST && !is_dir(path.begin()))
					return smkdir::file_exists;
			  	switch(_err)
				{
					case EEXIST:
					case 0:             return smkdir::ok;
					case ENOTDIR:       return smkdir::file_exists;
					case EINVAL:
					case ENOENT:       return smkdir::invalid_path;
					case ENAMETOOLONG: return smkdir::name_too_long;
					case EROFS:
					case EACCES:       return smkdir::access_denied;
					case ENOSPC:       return smkdir::not_enough_space;
					default:           return smkdir::other;
				}
			}
		}
		return smkdir::invalid_path;
	}

	static smkdir
	mkdirs(StringView const & path) noexcept
	{
		if(path.size() > 0)
		{	
			if(path.size() > max_path)
				return smkdir::name_too_long;
			else
			{
				bool _colon = false;
				size_t sub_len_total = 0;
				for(char const * it = path.begin(); *it != '\0';)
				{
					size_t sub_len = 0;
					bool terminate_ = false;
					for(char const * sit = it;; ++sit)
					{
						char ch = *sit;
						if(ch == ':')
						{
							if(_colon)
								return smkdir::invalid_path;
							_colon = true;
							if(*(++sit) != '\0')
								++sit;
							continue;
						}
						terminate_ = ch == '\0';
						if(ch == '\\' || ch == '/' || terminate_)
						{
							sub_len = size_t(sit - it);
							if(sub_len > 0)
							{
								sub_len_total += sub_len;
								break;
							}
						}
					}
					if(terminate_)
						return mkdir(path);
					else
					{
						auto _smkdir = mkdir(path.view(sub_len_total));
						if(_smkdir != smkdir::ok)
							return _smkdir;
					}
					it += sub_len;
				}
			}
		}
		return smkdir::invalid_path;
	}

	enum class srmdir
	{
		ok = 0,
		not_empty,
		not_a_dir,
		invalid_path,
		name_too_long,
		access_denied,
		busy,
		other
	};

	static srmdir
	rmdir(StringView const & path_) noexcept
	{
		if(path_.size() > 0)
		{
			if(path_.size() > max_path)
				return srmdir::name_too_long;
			else
			{
				char _path_buffer[max_path+1];
				auto path = _::_terminate_path(path_, _path_buffer);
				int _err;
			  #if defined(_WIN32)
				_err = ::_rmdir(path.begin());
			  #else 
				_err = ::rmdir(path.begin());
			  #endif
			  	if(_err == 0)
					return srmdir::ok;
				_err = int(errno);
			  	switch(_err)
				{
					case 0:             return srmdir::ok;
					case ENOTEMPTY:     return srmdir::not_empty;
					case ENOTDIR:       return srmdir::not_a_dir;
					case EINVAL:
					case ENOENT:        return srmdir::invalid_path;
					case ENAMETOOLONG:  return srmdir::name_too_long;
					case EACCES:        return srmdir::access_denied;
					case EBUSY:         return srmdir::busy;
					default:            return srmdir::other;
				}
			}
		}
		return srmdir::invalid_path;
	}

	enum class smkfile
	{
		ok = 0,
		regular_file_exists,
		irregular_file_exists,
		dir_exists,
		invalid_path,
		name_too_long,
		access_denied,
		busy,
		other
	};

	static smkfile
	mkfile(StringView const & path_) noexcept
	{
		if(path_.size() > 0)
		{
			if(path_.size() > max_path)
				return smkfile::name_too_long;
			else
			{
				char _path_buffer[max_path+1];
				auto path = _::_terminate_path(path_, _path_buffer);
				auto _type = get_type(path);
				if(_type == type::regular_file)
					return smkfile::regular_file_exists;
				else if(_type == type::dir)
					return smkfile::dir_exists;
				else if(_type != type::does_not_exist)
					return smkfile::irregular_file_exists;
				else
				{
					FILE * _handle = nullptr;
				#ifdef _MSC_VER
					fopen_s(&_handle, path.begin(), "wb");
				#else
					_handle = fopen(path.begin(), "wb");
				#endif
					if(_handle != nullptr)
					{
						fclose(_handle);
						return smkfile::ok;
					}
					else
					{
						int _err = int(errno);
						switch(_err)
						{
							case EINVAL:
							case ENOENT:        return smkfile::invalid_path;
							case ENAMETOOLONG:  return smkfile::name_too_long;
							case EACCES:        return smkfile::access_denied;
							case EBUSY:         return smkfile::busy;
							default:            return smkfile::other;
						}
					}
				}
			}
		}
		return smkfile::invalid_path;
	}

	enum class srmfile
	{
		ok = 0,
		not_a_file,
		file_not_found,
		invalid_path,
		name_too_long,
		access_denied,
		busy,
		other
	};

	static srmfile
	rmfile(StringView const & path_) noexcept
	{
		if(path_.size() > 0)
		{
			if(path_.size() > max_path)
				return srmfile::name_too_long;
			else
			{
				char _path_buffer[max_path+1];
				auto path = _::_terminate_path(path_, _path_buffer);
				if(remove(path.begin()) == 0)
					return srmfile::ok;
				else
				{
					int _err = int(errno);
					if(_err == ENOENT)
					{
						auto _type = get_type(path);
						if(_type == type::does_not_exist)
							return srmfile::file_not_found;
						else if(_type != type::regular_file)
							return srmfile::not_a_file;
					}
					switch(_err)
					{
						case EINVAL:
						case ENOENT:        return srmfile::invalid_path;
						case ENAMETOOLONG:  return srmfile::name_too_long;
						case EACCES:        return srmfile::access_denied;
						case EBUSY:         return srmfile::busy;
						default:            return srmfile::other;
					}
				}
			}
		}
		return srmfile::invalid_path;
	}

	enum class sls
	{
		ok = 0,
		invalid_path,
		name_too_long,
		dir_not_found,
		not_a_dir,
		access_denied,
		busy,
		other
	};

	template <class A = default_allocator>
	static sls
	ls(string_view const & path_, List<2,String<A>,A> & entries)
	{
		if(path_.size() > 0)
		{
			if(path_.size() > max_path - 2)
				return sls::name_too_long;
			else
			{
				// check if path points to a directory
				{
					auto _type = get_type(path_);
					if(_type == type::does_not_exist)
						return sls::dir_not_found;
					else if(_type != type::dir)
						return sls::not_a_dir;
				}
			  #ifdef _WIN32
				char find_info[max_path+1];
				{
					memcpy(&find_info[0], path_.begin(), path_.size());
					char * ch = &find_info[path_.size()-1];
					if(*ch == '/' || *ch == '\\')
					{
						*(++ch) = '*';
						*(++ch) = '\0';
					}
					else
					{
						*(++ch) = '/';
						*(++ch) = '*';
						*(++ch) = '\0';
					}
				}
				WIN32_FIND_DATAA fdata {}; 
				HANDLE _handle = FindFirstFileA(&find_info[0], &fdata);
				if(_handle != INVALID_HANDLE_VALUE)
				{
					entries = {};
					do
					{
						auto entry_name = StringView((char const *)fdata.cFileName);
						if(entry_name.size() > 0 && entry_name != "." && entry_name != "..")
							entries.insert_last(entry_name);
					}
					while(FindNextFileA(_handle, &fdata) != 0);
					FindClose(_handle);
					return sls::ok;
				}
				else
				{
					auto err = GetLastError();
					switch(err)
					{
						case ERROR_INVALID_DRIVE: 
						case ERROR_FILE_NOT_FOUND: return sls::dir_not_found;
						case ERROR_DIRECTORY:      return sls::not_a_dir;
						case ERROR_ACCESS_DENIED:  return sls::access_denied;
						case ERROR_PATH_BUSY:      return sls::busy;
						default:                   return sls::other;
					}
				}
			  #else
				char _path_buffer[ds::sys::max_path+1];
				auto path = ds::sys::_::_terminate_path(path_, _path_buffer);
				auto dir = ::opendir(path.begin());
				if(dir != nullptr)
				{
					entries = {};
					::dirent * entry = nullptr; 
					while((entry = ::readdir(dir)) != nullptr)
					{
						auto entry_name = StringView((char const *)entry->d_name);
						if(entry_name.size() > 0 && entry_name != "." && entry_name != "..")
							entries.insert_last(entry_name);
					}
					::closedir(dir);
					return sls::ok;
				}
				else
				{
					int err = int(errno);
					switch(err)
					{
						case EACCES:  return sls::access_denied;
						case ENOENT:  return sls::dir_not_found;
						case ENOTDIR: return sls::not_a_dir;
						case EBUSY:   return sls::busy;
						default:      return sls::other;
					}
				}
			  #endif
			}
		}
		return sls::invalid_path;
	}

} // namespace sys
} // namespace ds

#endif // DS_SYS
