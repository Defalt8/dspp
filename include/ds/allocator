#pragma once
#ifndef DS_ALLOCATOR
#define DS_ALLOCATOR

#include "common"

namespace ds {


// throwing allocator using ::operator new
class NewDeleteAllocator 
{
 public:
	struct allocation_failure : public std::bad_alloc
	{
		char const * what() const noexcept override { return "failed to allocate the requested amount of memory"; }
	};

	DS_nodiscard static inline void * 
	allocate(size_t size_, DS_maybe_unused size_t align_ = alignof(max_align_t)) noexcept(false)
	{
		void * block_ = ::operator new(size_, std::nothrow);
		ds_throw_if(block_ == nullptr, allocation_failure());
		ds_throw_if_alt(block_ == nullptr, return nullptr);
		return block_;
	}

	static inline void 
	deallocate(void * block_) noexcept
	{
		::operator delete(block_);
	}

};

using new_delete_allocator    = NewDeleteAllocator;


// no throw allocator using ::operator new
class NewDeleteNTAllocator 
{
 public:
	DS_nodiscard static inline void * 
	allocate(size_t size_, DS_maybe_unused size_t align_ = alignof(max_align_t)) noexcept
	{
		return ::operator new(size_, std::nothrow);
	}

	static inline void 
	deallocate(void * block_) noexcept
	{
		::operator delete(block_);
	}

};

using new_delete_nt_allocator = NewDeleteNTAllocator;


// throwing base allocator
class AllocatorBase 
{
 public:
	virtual ~AllocatorBase() = default;

	DS_nodiscard virtual void * 
	allocate(size_t size_, DS_maybe_unused size_t align_ = alignof(max_align_t)) noexcept(false)
	{
		return NewDeleteAllocator::allocate(size_, align_);
	}

	virtual void 
	deallocate(void * block_) noexcept
	{
		return NewDeleteAllocator::deallocate(block_);
	}

};

using allocator_base = AllocatorBase;

// no throw base allocator
class AllocatorNTBase 
{
 public:
	virtual ~AllocatorNTBase() = default;

	DS_nodiscard virtual void * 
	allocate(size_t size_, DS_maybe_unused size_t align_ = alignof(max_align_t)) noexcept
	{
		return NewDeleteNTAllocator::allocate(size_, align_);
	}

	virtual void 
	deallocate(void * block_) noexcept
	{
		return NewDeleteNTAllocator::deallocate(block_);
	}

};

using nt_allocator_base = AllocatorNTBase;

// a throwing static interface to non-static allocator types
template <class UID_, class A>
class AllocatorInterface
{
 public:
	using UID         = UID_;
	using Allocator   = A;
	
 private:
	static thread_local Allocator          * _allocator;
	static thread_local AllocatorInterface * _owner;

 public:
	struct interface_busy : exception 
	{
		char const * what() const noexcept override { return "allocator interface busy"; }
	};

	~AllocatorInterface()
	{
		if(_owner == this)
		{
			_allocator = nullptr;
			_owner     = nullptr;
		}
	}

	AllocatorInterface(A & allocator_)
	{
		if(_allocator == nullptr)
		{
			_allocator = &allocator_;
			_owner     = this;
		}
		else
			ds_throw(interface_busy());
	}
	
	AllocatorInterface &
	operator=(A & allocator_)
	{
		if(&allocator_ != _allocator)
		{
			if(_allocator == nullptr || _owner == this)
				_allocator = &allocator_;
			else
				ds_throw(interface_busy());
		}
		return *this;
	}
	
	DS_nodiscard static inline void * 
	allocate(size_t size_, size_t align_ = alignof(max_align_t))
	{
		if(_allocator != nullptr)
			return _allocator->allocate(size_, align_);
		return nullptr;
	}

	static inline void 
	deallocate(void * block_) noexcept
	{
		if(_allocator != nullptr)
			_allocator->deallocate(block_);
	}

};

template <class UID, class A>
thread_local A * AllocatorInterface<UID,A>::_allocator = nullptr;

template <class UID, class A>
thread_local AllocatorInterface<UID,A> * AllocatorInterface<UID,A>::_owner = nullptr;

template <class UID, class A>
using allocator_interface = AllocatorInterface<UID,A>;


// a no-throw static interface to non-static allocator types
template <class UID_, class A>
class AllocatorNTInterface
{
 public:
	using UID         = UID_;
	using Allocator   = A;
	
 private:
	static thread_local Allocator            * _allocator;
	static thread_local AllocatorNTInterface * _owner;

 public:
	~AllocatorNTInterface()
	{
		if(_owner == this)
		{
			_allocator = nullptr;
			_owner     = nullptr;
		}
	}

	AllocatorNTInterface(A & allocator_)
	{
		if(_allocator == nullptr)
		{
			_allocator = &allocator_;
			_owner     = this;
		}
	}
	
	AllocatorNTInterface &
	operator=(A & allocator_)
	{
		if(&allocator_ != _allocator)
		{
			if(_allocator == nullptr || _owner == this)
				_allocator = &allocator_;
		}
		return *this;
	}
	
	DS_nodiscard static inline void * 
	allocate(size_t size_, size_t align_ = alignof(max_align_t))
	{
		if(_allocator != nullptr)
			return _allocator->allocate(size_, align_);
		return nullptr;
	}

	static inline void 
	deallocate(void * block_) noexcept
	{
		if(_allocator != nullptr)
			_allocator->deallocate(block_);
	}

};

template <class UID, class A>
thread_local A * AllocatorNTInterface<UID,A>::_allocator = nullptr;

template <class UID, class A>
thread_local AllocatorNTInterface<UID,A> * AllocatorNTInterface<UID,A>::_owner = nullptr;

template <class UID, class A>
using nt_allocator_interface = AllocatorNTInterface<UID,A>;


// a throwing helper class to store and manage non-static allocators and their interface
template <class UID_, class A>
class AllocatorWrapper
{
 public:
	using UID         = UID_;
	using Allocator   = A;
	using Interface   = AllocatorInterface<UID,A>;

 private:
	Allocator _allocator;
	Interface _interface { _allocator };

 public:
	template <typename... Args, enable_if_t<is_constructible<Allocator,Args...>::value,int> = 0>
	AllocatorWrapper(Args &&... args)
		: _allocator { ds::forward<Args>(args)... }
	{}

};

template <class UID, class A>
using allocator_wrapper = AllocatorWrapper<UID,A>;


// a no-throw helper class to store and manage non-static allocators and their interface
template <class UID_, class A>
class AllocatorNTWrapper
{
 public:
	using UID         = UID_;
	using Allocator   = A;
	using Interface   = AllocatorNTInterface<UID,A>;

 private:
	Allocator _allocator;
	Interface _interface { _allocator };

 public:
	template <typename... Args, enable_if_t<is_constructible<Allocator,Args...>::value,int> = 0>
	AllocatorNTWrapper(Args &&... args)
		: _allocator { ds::forward<Args>(args)... }
	{}
	
};

template <class UID, class A>
using nt_allocator_wrapper = AllocatorNTWrapper<UID,A>;


template <size_t size_, size_t align_ = alignof(max_align_t)>
struct AlignedBytes
{
	alignas(align_) byte_t bytes[size_];
	
	AlignedBytes(noinit_t)
	{}
	
	AlignedBytes()
		: bytes {}
	{}
	
	size_t      size()  const noexcept { return size_; }
	byte_ptr_t  begin()       noexcept { return &bytes[0]; }
	byte_ptr_t  end()         noexcept { return &bytes[size_]; }
	byte_cptr_t begin() const noexcept { return &bytes[0]; }
	byte_cptr_t end()   const noexcept { return &bytes[size_]; }
};

template <size_t size_, align_t align_ = alignof(max_align_t)>
using aligned_bytes = AlignedBytes<size_,align_>;


template <size_t sz_, size_t al_ = alignof(max_align_t)>
class LocalForwardAllocator : public AllocatorBase
{
	AlignedBytes<sz_,al_>     mem {noinit};
	byte_ptr_t                head = &mem.bytes[0];

 public:
	struct allocation_failure : public std::bad_alloc
	{
		char const * what() const noexcept override { return "failed to allocate the requested amount of memory"; }
	};

	DS_nodiscard void * 
	allocate(size_t size_, align_t align_ = alignof(max_align_t)) noexcept(false) override
	{
		size_t      const offset_  = (~size_t(head)+1) & (--align_);
		byte_ptr_t  const block_   = head + offset_;
		byte_cptr_t const mem_end = mem.end();
		if(block_ >= mem_end || size_t(mem_end - block_) < size_)
		{
			ds_throw(allocation_failure());
			ds_throw_alt(return nullptr);
		}
		head = block_ + size_;
		return block_;
	}

	inline void 
	deallocate(void * block_) noexcept override
	{}

};

template <size_t size_, align_t align_ = alignof(max_align_t)>
using local_forward_allocator = LocalForwardAllocator<size_,align_>;


template <size_t sz_, size_t al_ = alignof(max_align_t)>
class LocalForwardNTAllocator : public AllocatorNTBase
{
	AlignedBytes<sz_,al_>     mem {noinit};
	byte_ptr_t                head = &mem.bytes[0];

 public:
	struct allocation_failure : public std::bad_alloc
	{
		char const * what() const noexcept override { return "failed to allocate the requested amount of memory"; }
	};

	DS_nodiscard void * 
	allocate(size_t size_, align_t align_ = alignof(max_align_t)) noexcept override
	{
		size_t      const offset_  = (~size_t(head)+1) & (--align_);
		byte_ptr_t  const block_   = head + offset_;
		byte_cptr_t const mem_end = mem.end();
		if(block_ >= mem_end || size_t(mem_end - block_) < size_)
			return nullptr;
		head = block_ + size_;
		return block_;
	}

	inline void 
	deallocate(void * block_) noexcept override
	{}

};

template <size_t size_, align_t align_ = alignof(max_align_t)>
using local_forward_nt_allocator = LocalForwardNTAllocator<size_,align_>;


class DynamicForwardAllocator : public AllocatorBase
{
	byte_ptr_t   _mem  = nullptr;
	byte_cptr_t  _end  = nullptr;
	byte_ptr_t   _head = _mem;

 public:
	struct allocation_failure : public std::bad_alloc
	{
		char const * what() const noexcept override { return "ds::dynamic_forward_allocator allocation failure"; }
	};

	~DynamicForwardAllocator()
	{
		if(_mem != nullptr)
			NewDeleteAllocator::deallocate(_mem);
	}

	DynamicForwardAllocator(size_t size_, align_t align_ = alignof(max_align_t))
		: _mem { static_cast<byte_ptr_t>(NewDeleteAllocator::allocate(size_, align_)) }
		, _end { _mem == nullptr ? nullptr : (_mem + size_) }
	{}

	DS_nodiscard void * 
	allocate(size_t size_, align_t align_ = alignof(max_align_t)) noexcept(false) override
	{
		size_t      const offset_  = (~size_t(_head)+1) & (--align_);
		byte_ptr_t  const block_   = _head + offset_;
		if(_mem == nullptr || block_ >= _end || size_t(_end - block_) < size_)
		{
			ds_throw(allocation_failure());
			ds_throw_alt(return nullptr);
		}
		_head = block_ + size_;
		return block_;
	}

	inline void 
	deallocate(void * block_) noexcept override
	{}

};

using dynamic_forward_allocator = DynamicForwardAllocator;

class DynamicForwardNTAllocator : public AllocatorNTBase
{
	byte_ptr_t   _mem  = nullptr;
	byte_cptr_t  _end  = nullptr;
	byte_ptr_t   _head = _mem;

 public:

	~DynamicForwardNTAllocator()
	{
		if(_mem != nullptr)
			NewDeleteAllocator::deallocate(_mem);
	}

	DynamicForwardNTAllocator(size_t size_, align_t align_ = alignof(max_align_t))
		: _mem { static_cast<byte_ptr_t>(NewDeleteAllocator::allocate(size_, align_)) }
		, _end { _mem == nullptr ? nullptr : _mem + size_ }
	{}

	DS_nodiscard void * 
	allocate(size_t size_, align_t align_ = alignof(max_align_t)) noexcept override
	{
		size_t      const offset_  = (~size_t(_head)+1) & (--align_);
		byte_ptr_t  const block_   = _head + offset_;
		if(_mem == nullptr || block_ >= _end || size_t(_end - block_) < size_)
			return nullptr;
		_head = block_ + size_;
		return block_;
	}

	inline void 
	deallocate(void * block_) noexcept override
	{}

};

using dynamic_forward_nt_allocator = DynamicForwardNTAllocator;


using default_allocator    = NewDeleteAllocator;
using default_nt_allocator = NewDeleteNTAllocator;


} // namespace ds

#endif // DS_ALLOCATOR
